---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "seqera_kubernetes_credential Resource - terraform-provider-seqera"
subcategory: ""
description: |-
  Manage Kubernetes credentials in Seqera platform using this resource.
  Kubernetes credentials enable secure connections to Kubernetes clusters for workflow
  execution. Supports two authentication methods: Service Account Token and X.509 Client Certificates.
---

# seqera_kubernetes_credential (Resource)

Manage Kubernetes credentials in Seqera platform using this resource.

Kubernetes credentials enable secure connections to Kubernetes clusters for workflow
execution. Supports two authentication methods: Service Account Token and X.509 Client Certificates.

## Example Usage

```terraform
# Seqera Kubernetes Credentials Examples
#
# Kubernetes credentials enable secure connections to Kubernetes clusters for workflow
# execution. Supports two authentication methods:
# 1. Service Account Token - token-based authentication
# 2. X.509 Client Certificates - certificate-based authentication
#
# SECURITY BEST PRACTICES:
# - Store tokens and certificates securely using secret management
# - Use separate credentials for different environments
# - Rotate credentials regularly
# - Use service accounts with minimal required permissions
# - Never commit credentials to version control

terraform {
  required_providers {
    seqera = {
      source = "seqeralabs/seqera"
    }
  }
}

# =============================================================================
# Example 1: Service Account Token Authentication
# =============================================================================

resource "seqera_kubernetes_credential" "service_account" {
  name         = "k8s-service-account"
  workspace_id = seqera_workspace.main.id

  token = var.k8s_service_account_token
}

# =============================================================================
# Example 2: X.509 Client Certificate Authentication
# =============================================================================

resource "seqera_kubernetes_credential" "client_cert" {
  name         = "k8s-client-cert"
  workspace_id = seqera_workspace.main.id

  client_certificate = var.k8s_client_certificate
  private_key        = var.k8s_private_key
}

# =============================================================================
# Example 3: Service Account Token from File
# =============================================================================

resource "seqera_kubernetes_credential" "token_from_file" {
  name         = "k8s-token-file"
  workspace_id = seqera_workspace.main.id

  token = file("/var/run/secrets/kubernetes.io/serviceaccount/token")
}

# =============================================================================
# Example 4: Client Certificate from Files
# =============================================================================

resource "seqera_kubernetes_credential" "cert_from_files" {
  name         = "k8s-cert-files"
  workspace_id = seqera_workspace.main.id

  client_certificate = file("~/.kube/client.crt")
  private_key        = file("~/.kube/client.key")
}

# =============================================================================
# Example 5: Using kubectl to Extract Credentials
# =============================================================================
# Extract service account token from current context

data "external" "k8s_token" {
  program = ["bash", "-c", <<-EOT
    TOKEN=$(kubectl get secret $(kubectl get serviceaccount default -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 -d)
    echo "{\"token\": \"$TOKEN\"}"
  EOT
  ]
}

resource "seqera_kubernetes_credential" "from_kubectl" {
  name         = "k8s-kubectl-token"
  workspace_id = seqera_workspace.main.id

  token = data.external.k8s_token.result.token
}

# =============================================================================
# Example 6: Multiple Kubernetes Clusters
# =============================================================================

locals {
  k8s_clusters = {
    "dev" = {
      token = var.k8s_dev_token
    }
    "staging" = {
      token = var.k8s_staging_token
    }
    "prod" = {
      token = var.k8s_prod_token
    }
  }
}

resource "seqera_kubernetes_credential" "clusters" {
  for_each = local.k8s_clusters

  name         = "k8s-${each.key}"
  workspace_id = seqera_workspace.main.id
  token        = each.value.token
}

# =============================================================================
# Example 7: AWS EKS with IAM Authentication
# =============================================================================
# For EKS, generate a token using AWS CLI

data "external" "eks_token" {
  program = ["bash", "-c", <<-EOT
    TOKEN=$(aws eks get-token --cluster-name my-cluster --query 'status.token' --output text)
    echo "{\"token\": \"$TOKEN\"}"
  EOT
  ]
}

resource "seqera_kubernetes_credential" "eks" {
  name         = "k8s-eks"
  workspace_id = seqera_workspace.main.id

  token = data.external.eks_token.result.token
}

# =============================================================================
# Example 8: GCP GKE with gcloud Authentication
# =============================================================================
# For GKE, generate a token using gcloud

data "external" "gke_token" {
  program = ["bash", "-c", <<-EOT
    TOKEN=$(gcloud auth print-access-token)
    echo "{\"token\": \"$TOKEN\"}"
  EOT
  ]
}

resource "seqera_kubernetes_credential" "gke" {
  name         = "k8s-gke"
  workspace_id = seqera_workspace.main.id

  token = data.external.gke_token.result.token
}

# =============================================================================
# Example 9: Azure AKS with Service Principal
# =============================================================================
# For AKS, use service principal credentials

data "external" "aks_token" {
  program = ["bash", "-c", <<-EOT
    TOKEN=$(az account get-access-token --resource https://management.azure.com/ --query accessToken --output tsv)
    echo "{\"token\": \"$TOKEN\"}"
  EOT
  ]
}

resource "seqera_kubernetes_credential" "aks" {
  name         = "k8s-aks"
  workspace_id = seqera_workspace.main.id

  token = data.external.aks_token.result.token
}

# =============================================================================
# Example 10: Using Kubernetes Provider to Create Service Account
# =============================================================================

provider "kubernetes" {
  config_path = "~/.kube/config"
}

# Create a service account for Seqera
resource "kubernetes_service_account" "seqera" {
  metadata {
    name      = "seqera-agent"
    namespace = "default"
  }
}

# Create a cluster role binding
resource "kubernetes_cluster_role_binding" "seqera" {
  metadata {
    name = "seqera-agent-binding"
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = "cluster-admin"
  }

  subject {
    kind      = "ServiceAccount"
    name      = kubernetes_service_account.seqera.metadata[0].name
    namespace = kubernetes_service_account.seqera.metadata[0].namespace
  }
}

# Get the service account token
data "kubernetes_secret" "seqera_token" {
  metadata {
    name      = kubernetes_service_account.seqera.default_secret_name
    namespace = kubernetes_service_account.seqera.metadata[0].namespace
  }
}

resource "seqera_kubernetes_credential" "managed_sa" {
  name         = "k8s-managed-sa"
  workspace_id = seqera_workspace.main.id

  token = data.kubernetes_secret.seqera_token.data.token
}

# =============================================================================
# Example 11: Using AWS Secrets Manager for Token Storage
# =============================================================================

data "aws_secretsmanager_secret_version" "k8s_token" {
  secret_id = "seqera/k8s/token"
}

resource "seqera_kubernetes_credential" "from_secrets_manager" {
  name         = "k8s-secrets-manager"
  workspace_id = seqera_workspace.main.id

  token = jsondecode(data.aws_secretsmanager_secret_version.k8s_token.secret_string)["token"]
}

# =============================================================================
# Example 12: Using HashiCorp Vault for Certificate Storage
# =============================================================================

data "vault_generic_secret" "k8s_certs" {
  path = "secret/k8s/certificates"
}

resource "seqera_kubernetes_credential" "from_vault" {
  name         = "k8s-vault"
  workspace_id = seqera_workspace.main.id

  client_certificate = data.vault_generic_secret.k8s_certs.data["client_certificate"]
  private_key        = data.vault_generic_secret.k8s_certs.data["private_key"]
}

# =============================================================================
# Example 13: Certificate Rotation Strategy
# =============================================================================
# Use terraform lifecycle to manage certificate rotation

resource "seqera_kubernetes_credential" "rotatable" {
  name         = "k8s-rotatable"
  workspace_id = seqera_workspace.main.id

  client_certificate = var.k8s_client_certificate
  private_key        = var.k8s_private_key

  lifecycle {
    create_before_destroy = true
  }
}

# =============================================================================
# Example 14: Generating Kubernetes Credentials with tls Provider
# =============================================================================

provider "tls" {}

# Generate a private key
resource "tls_private_key" "k8s_client" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

# Create a certificate signing request
resource "tls_cert_request" "k8s_client" {
  private_key_pem = tls_private_key.k8s_client.private_key_pem

  subject {
    common_name  = "seqera-client"
    organization = "Seqera"
  }
}

# Note: You would need to sign this CSR with your Kubernetes CA
# This example shows the structure only

resource "seqera_kubernetes_credential" "generated" {
  name         = "k8s-generated"
  workspace_id = seqera_workspace.main.id

  # In production, use the signed certificate
  client_certificate = tls_cert_request.k8s_client.cert_request_pem
  private_key        = tls_private_key.k8s_client.private_key_pem
}

# =============================================================================
# Example 15: Using Namespace-Specific Service Accounts
# =============================================================================

resource "kubernetes_namespace" "seqera" {
  metadata {
    name = "seqera-platform"
  }
}

resource "kubernetes_service_account" "namespace_specific" {
  metadata {
    name      = "seqera-sa"
    namespace = kubernetes_namespace.seqera.metadata[0].name
  }
}

resource "kubernetes_role" "seqera" {
  metadata {
    name      = "seqera-role"
    namespace = kubernetes_namespace.seqera.metadata[0].name
  }

  rule {
    api_groups = ["", "batch", "apps"]
    resources  = ["pods", "jobs", "deployments", "services", "configmaps"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }
}

resource "kubernetes_role_binding" "seqera" {
  metadata {
    name      = "seqera-role-binding"
    namespace = kubernetes_namespace.seqera.metadata[0].name
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "Role"
    name      = kubernetes_role.seqera.metadata[0].name
  }

  subject {
    kind      = "ServiceAccount"
    name      = kubernetes_service_account.namespace_specific.metadata[0].name
    namespace = kubernetes_namespace.seqera.metadata[0].name
  }
}

# =============================================================================
# Using Kubernetes Credentials
# =============================================================================
# After creating Kubernetes credentials:
#
# 1. For Service Account Token:
#    - Ensure the service account has appropriate RBAC permissions
#    - Token should have access to required namespaces
#    - Consider token expiration and renewal
#
# 2. For X.509 Client Certificates:
#    - Ensure certificates are signed by the cluster CA
#    - Monitor certificate expiration dates
#    - Implement certificate rotation procedures
#
# 3. Kubernetes Cluster Requirements:
#    - API server must be accessible from Seqera Platform
#    - Required RBAC permissions for workflow execution
#    - Network connectivity between Seqera and cluster

# =============================================================================
# Required Kubernetes RBAC Permissions
# =============================================================================
# The service account or certificate should have at minimum:
#
# apiVersion: rbac.authorization.k8s.io/v1
# kind: ClusterRole
# metadata:
#   name: seqera-executor
# rules:
# - apiGroups: [""]
#   resources: ["pods", "pods/log", "pods/status"]
#   verbs: ["get", "list", "watch", "create", "delete"]
# - apiGroups: ["batch"]
#   resources: ["jobs"]
#   verbs: ["get", "list", "watch", "create", "delete"]
# - apiGroups: [""]
#   resources: ["configmaps", "secrets"]
#   verbs: ["get", "list", "create"]

# =============================================================================
# SECURITY RECOMMENDATIONS
# =============================================================================
#
# 1. Store tokens and certificates in secret management systems
# 2. Use separate credentials for different environments
# 3. Rotate credentials regularly (every 90 days recommended)
# 4. Use namespace-specific service accounts with minimal permissions
# 5. Monitor credential usage and access logs
# 6. Implement automatic token renewal for long-lived credentials
# 7. Use certificate-based auth for production environments
# 8. Ensure API server endpoints are secure (TLS enabled)
# 9. Audit RBAC permissions regularly
# 10. Use network policies to restrict pod communication
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) Display name for the credential (max 100 characters). Requires replacement if changed.

### Optional

- `client_certificate` (String, Sensitive) X.509 client certificate for Kubernetes authentication (optional). Required if using certificate-based authentication.
- `private_key` (String, Sensitive) Private key for X.509 client certificate (optional). Required if using certificate-based authentication.
- `token` (String, Sensitive) Service Account token for Kubernetes authentication (optional). Required if using token-based authentication.
- `workspace_id` (Number) Workspace numeric identifier

### Read-Only

- `credentials_id` (String) Credentials string identifier
- `id` (String) Unique identifier for the credential (max 22 characters)
- `keys` (Attributes) (see [below for nested schema](#nestedatt--keys))
- `provider_type` (String) Cloud provider type (automatically set to "k8s"). Default: "k8s"; must be "k8s"

<a id="nestedatt--keys"></a>
### Nested Schema for `keys`

## Import

Import is supported using the following syntax:

In Terraform v1.5.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `id` attribute, for example:

```terraform
import {
  to = seqera_kubernetes_credential.my_seqera_kubernetes_credential
  id = "..."
}
```

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

```shell
terraform import seqera_kubernetes_credential.my_seqera_kubernetes_credential "..."
```
