// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/seqeralabs/terraform-provider-seqera/internal/provider/typeconvert"
	tfTypes "github.com/seqeralabs/terraform-provider-seqera/internal/provider/types"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/models/operations"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/models/shared"
)

func (r *CredentialResourceModel) RefreshFromSharedCreateCredentialsResponse(ctx context.Context, resp *shared.CreateCredentialsResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CredentialsID = types.StringPointerValue(resp.CredentialsID)
	}

	return diags
}

func (r *CredentialResourceModel) RefreshFromSharedCredentialsOutput(ctx context.Context, resp *shared.CredentialsOutput) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.BaseURL = types.StringPointerValue(resp.BaseURL)
		r.Category = types.StringPointerValue(resp.Category)
		r.DateCreated = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.DateCreated))
		r.Deleted = types.BoolPointerValue(resp.Deleted)
		r.Description = types.StringPointerValue(resp.Description)
		r.ID = types.StringPointerValue(resp.ID)
		if resp.Keys.AWSCodeCommitCredentialsOutput != nil {
			r.Keys.Codecommit = &tfTypes.AWSCodeCommitCredentials{}
			codecommitPriorData := r.Keys.Codecommit
			r.Keys.Codecommit.Token = types.StringPointerValue(resp.Keys.AWSCodeCommitCredentialsOutput.Token)
			r.Keys.Codecommit.Username = types.StringPointerValue(resp.Keys.AWSCodeCommitCredentialsOutput.Username)
			r.Keys.Codecommit.Password = codecommitPriorData.Password
		}
		if resp.Keys.AWSCredentialsOutput != nil {
			r.Keys.Aws = &tfTypes.AWSCredentials{}
			awsPriorData := r.Keys.Aws
			r.Keys.Aws.AccessKey = types.StringPointerValue(resp.Keys.AWSCredentialsOutput.AccessKey)
			r.Keys.Aws.AssumeRoleArn = types.StringPointerValue(resp.Keys.AWSCredentialsOutput.AssumeRoleArn)
			r.Keys.Aws.SecretKey = awsPriorData.SecretKey
		}
		if resp.Keys.AzureCloudCredentialsOutput != nil {
			r.Keys.AzureCloud = &tfTypes.AzureCloudCredentials{}
			azureCloudPriorData := r.Keys.AzureCloud
			r.Keys.AzureCloud.BatchName = types.StringPointerValue(resp.Keys.AzureCloudCredentialsOutput.BatchName)
			r.Keys.AzureCloud.ClientID = types.StringPointerValue(resp.Keys.AzureCloudCredentialsOutput.ClientID)
			r.Keys.AzureCloud.StorageName = types.StringPointerValue(resp.Keys.AzureCloudCredentialsOutput.StorageName)
			r.Keys.AzureCloud.SubscriptionID = types.StringPointerValue(resp.Keys.AzureCloudCredentialsOutput.SubscriptionID)
			r.Keys.AzureCloud.TenantID = types.StringPointerValue(resp.Keys.AzureCloudCredentialsOutput.TenantID)
			r.Keys.AzureCloud.BatchKey = azureCloudPriorData.BatchKey
			r.Keys.AzureCloud.ClientSecret = azureCloudPriorData.ClientSecret
			r.Keys.AzureCloud.StorageKey = azureCloudPriorData.StorageKey
		}
		if resp.Keys.AzureCredentialsOutput != nil {
			r.Keys.Azure = &tfTypes.AzureCredentials{}
			azurePriorData := r.Keys.Azure
			r.Keys.Azure.BatchName = types.StringPointerValue(resp.Keys.AzureCredentialsOutput.BatchName)
			r.Keys.Azure.StorageName = types.StringPointerValue(resp.Keys.AzureCredentialsOutput.StorageName)
			r.Keys.Azure.BatchKey = azurePriorData.BatchKey
			r.Keys.Azure.StorageKey = azurePriorData.StorageKey
		}
		if resp.Keys.AzureEntraCredentialsOutput != nil {
			r.Keys.AzureEntra = &tfTypes.AzureEntraCredentials{}
			azureEntraPriorData := r.Keys.AzureEntra
			r.Keys.AzureEntra.BatchName = types.StringPointerValue(resp.Keys.AzureEntraCredentialsOutput.BatchName)
			r.Keys.AzureEntra.ClientID = types.StringPointerValue(resp.Keys.AzureEntraCredentialsOutput.ClientID)
			r.Keys.AzureEntra.StorageName = types.StringPointerValue(resp.Keys.AzureEntraCredentialsOutput.StorageName)
			r.Keys.AzureEntra.TenantID = types.StringPointerValue(resp.Keys.AzureEntraCredentialsOutput.TenantID)
			r.Keys.AzureEntra.BatchKey = azureEntraPriorData.BatchKey
			r.Keys.AzureEntra.ClientSecret = azureEntraPriorData.ClientSecret
			r.Keys.AzureEntra.StorageKey = azureEntraPriorData.StorageKey
		}
		if resp.Keys.AzureReposCredentialsOutput != nil {
			r.Keys.Azurerepos = &tfTypes.AzureReposCredentials{}
			azurereposPriorData := r.Keys.Azurerepos
			r.Keys.Azurerepos.Username = types.StringPointerValue(resp.Keys.AzureReposCredentialsOutput.Username)
			r.Keys.Azurerepos.Password = azurereposPriorData.Password
			r.Keys.Azurerepos.Token = azurereposPriorData.Token
		}
		if resp.Keys.BitBucketCredentialsOutput != nil {
			r.Keys.Bitbucket = &tfTypes.BitBucketCredentials{}
			bitbucketPriorData := r.Keys.Bitbucket
			r.Keys.Bitbucket.Username = types.StringPointerValue(resp.Keys.BitBucketCredentialsOutput.Username)
			r.Keys.Bitbucket.Password = bitbucketPriorData.Password
			r.Keys.Bitbucket.Token = bitbucketPriorData.Token
		}
		if resp.Keys.ContainerRegistryCredentialsOutput != nil {
			r.Keys.ContainerReg = &tfTypes.ContainerRegistryCredentials{}
			containerRegPriorData := r.Keys.ContainerReg
			r.Keys.ContainerReg.Registry = types.StringPointerValue(resp.Keys.ContainerRegistryCredentialsOutput.Registry)
			r.Keys.ContainerReg.UserName = types.StringPointerValue(resp.Keys.ContainerRegistryCredentialsOutput.UserName)
			r.Keys.ContainerReg.Password = containerRegPriorData.Password
		}
		if resp.Keys.GiteaCredentialsOutput != nil {
			r.Keys.Gitea = &tfTypes.GiteaCredentials{}
			giteaPriorData := r.Keys.Gitea
			r.Keys.Gitea.Username = types.StringPointerValue(resp.Keys.GiteaCredentialsOutput.Username)
			r.Keys.Gitea.Password = giteaPriorData.Password
			r.Keys.Gitea.Token = giteaPriorData.Token
		}
		if resp.Keys.GitHubCredentialsOutput != nil {
			r.Keys.Github = &tfTypes.GitHubCredentials{}
			githubPriorData := r.Keys.Github
			r.Keys.Github.Username = types.StringPointerValue(resp.Keys.GitHubCredentialsOutput.Username)
			r.Keys.Github.Password = githubPriorData.Password
			r.Keys.Github.Token = githubPriorData.Token
		}
		if resp.Keys.GitLabCredentialsOutput != nil {
			r.Keys.Gitlab = &tfTypes.GitLabCredentials{}
			gitlabPriorData := r.Keys.Gitlab
			r.Keys.Gitlab.Username = types.StringPointerValue(resp.Keys.GitLabCredentialsOutput.Username)
			r.Keys.Gitlab.Password = gitlabPriorData.Password
			r.Keys.Gitlab.Token = gitlabPriorData.Token
		}
		if resp.Keys.GoogleCredentialsOutput != nil {
			r.Keys.Google = &tfTypes.GoogleCredentials{}
			googlePriorData := r.Keys.Google
			r.Keys.Google.Data = googlePriorData.Data
		}
		if resp.Keys.KubernetesCredentialsOutput != nil {
			r.Keys.K8s = &tfTypes.KubernetesCredentials{}
			k8sPriorData := r.Keys.K8s
			r.Keys.K8s.Certificate = k8sPriorData.Certificate
			r.Keys.K8s.PrivateKey = k8sPriorData.PrivateKey
			r.Keys.K8s.Token = k8sPriorData.Token
		}
		if resp.Keys.LocalSecurityKeysOutput != nil {
			r.Keys.Local = &tfTypes.LocalSecurityKeys{}
			localPriorData := r.Keys.Local
			r.Keys.Local.Password = localPriorData.Password
		}
		if resp.Keys.S3CompatibleCredentialsOutput != nil {
			r.Keys.S3 = &tfTypes.S3CompatibleCredentials{}
			s3PriorData := r.Keys.S3
			r.Keys.S3.AccessKey = types.StringPointerValue(resp.Keys.S3CompatibleCredentialsOutput.AccessKey)
			r.Keys.S3.PathStyleAccessEnabled = types.BoolPointerValue(resp.Keys.S3CompatibleCredentialsOutput.PathStyleAccessEnabled)
			r.Keys.S3.SecretKey = s3PriorData.SecretKey
		}
		if resp.Keys.SeqeraComputeCredentialsOutput != nil {
			r.Keys.Seqeracompute = &tfTypes.SeqeraComputeCredentials{}
			seqeracomputePriorData := r.Keys.Seqeracompute
			r.Keys.Seqeracompute.AccessKey = types.StringPointerValue(resp.Keys.SeqeraComputeCredentialsOutput.AccessKey)
			r.Keys.Seqeracompute.AssumeRoleArn = types.StringPointerValue(resp.Keys.SeqeraComputeCredentialsOutput.AssumeRoleArn)
			r.Keys.Seqeracompute.SecretKey = seqeracomputePriorData.SecretKey
		}
		if resp.Keys.SSHCredentialsOutput != nil {
			r.Keys.SSH = &tfTypes.SSHCredentials{}
			sshPriorData := r.Keys.SSH
			r.Keys.SSH.Passphrase = sshPriorData.Passphrase
			r.Keys.SSH.PrivateKey = sshPriorData.PrivateKey
		}
		if resp.Keys.TowerAgentCredentials != nil {
			r.Keys.TwAgent = &tfTypes.TowerAgentCredentials{}
			r.Keys.TwAgent.ConnectionID = types.StringPointerValue(resp.Keys.TowerAgentCredentials.ConnectionID)
			r.Keys.TwAgent.Shared = types.BoolPointerValue(resp.Keys.TowerAgentCredentials.Shared)
			r.Keys.TwAgent.WorkDir = types.StringPointerValue(resp.Keys.TowerAgentCredentials.WorkDir)
		}
		r.LastUpdated = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.LastUpdated))
		r.LastUsed = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.LastUsed))
		r.Name = types.StringValue(resp.Name)
		r.ProviderType = types.StringValue(string(resp.ProviderType))
	}

	return diags
}

func (r *CredentialResourceModel) RefreshFromSharedDescribeCredentialsResponse(ctx context.Context, resp *shared.DescribeCredentialsResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		diags.Append(r.RefreshFromSharedCredentialsOutput(ctx, resp.Credentials)...)

		if diags.HasError() {
			return diags
		}

	}

	return diags
}

func (r *CredentialResourceModel) ToOperationsCreateCredentialsRequest(ctx context.Context) (*operations.CreateCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var workspaceID int64
	workspaceID = r.WorkspaceID.ValueInt64()

	createCredentialsRequest, createCredentialsRequestDiags := r.ToSharedCreateCredentialsRequest(ctx)
	diags.Append(createCredentialsRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateCredentialsRequest{
		WorkspaceID:              workspaceID,
		CreateCredentialsRequest: *createCredentialsRequest,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToOperationsDeleteCredentialsRequest(ctx context.Context) (*operations.DeleteCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var credentialsID string
	credentialsID = r.CredentialsID.ValueString()

	workspaceID := new(int64)
	if !r.WorkspaceID.IsUnknown() && !r.WorkspaceID.IsNull() {
		*workspaceID = r.WorkspaceID.ValueInt64()
	} else {
		workspaceID = nil
	}
	checked := new(bool)
	if !r.Checked.IsUnknown() && !r.Checked.IsNull() {
		*checked = r.Checked.ValueBool()
	} else {
		checked = nil
	}
	out := operations.DeleteCredentialsRequest{
		CredentialsID: credentialsID,
		WorkspaceID:   workspaceID,
		Checked:       checked,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToOperationsDescribeCredentialsRequest(ctx context.Context) (*operations.DescribeCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var credentialsID string
	credentialsID = r.CredentialsID.ValueString()

	workspaceID := new(int64)
	if !r.WorkspaceID.IsUnknown() && !r.WorkspaceID.IsNull() {
		*workspaceID = r.WorkspaceID.ValueInt64()
	} else {
		workspaceID = nil
	}
	out := operations.DescribeCredentialsRequest{
		CredentialsID: credentialsID,
		WorkspaceID:   workspaceID,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToOperationsUpdateCredentialsRequest(ctx context.Context) (*operations.UpdateCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var credentialsID string
	credentialsID = r.CredentialsID.ValueString()

	workspaceID := new(int64)
	if !r.WorkspaceID.IsUnknown() && !r.WorkspaceID.IsNull() {
		*workspaceID = r.WorkspaceID.ValueInt64()
	} else {
		workspaceID = nil
	}
	updateCredentialsRequest, updateCredentialsRequestDiags := r.ToSharedUpdateCredentialsRequest(ctx)
	diags.Append(updateCredentialsRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateCredentialsRequest{
		CredentialsID:            credentialsID,
		WorkspaceID:              workspaceID,
		UpdateCredentialsRequest: *updateCredentialsRequest,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToSharedCreateCredentialsRequest(ctx context.Context) (*shared.CreateCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	credentials, credentialsDiags := r.ToSharedCredentialsInput(ctx)
	diags.Append(credentialsDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := shared.CreateCredentialsRequest{
		Credentials: credentials,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToSharedCredentialsInput(ctx context.Context) (*shared.CredentialsInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	id := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id = r.ID.ValueString()
	} else {
		id = nil
	}
	var name string
	name = r.Name.ValueString()

	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	providerType := shared.CredentialsProviderType(r.ProviderType.ValueString())
	baseURL := new(string)
	if !r.BaseURL.IsUnknown() && !r.BaseURL.IsNull() {
		*baseURL = r.BaseURL.ValueString()
	} else {
		baseURL = nil
	}
	category := new(string)
	if !r.Category.IsUnknown() && !r.Category.IsNull() {
		*category = r.Category.ValueString()
	} else {
		category = nil
	}
	var keys shared.SecurityKeys
	var awsCredentials *shared.AWSCredentials
	if r.Keys.Aws != nil {
		accessKey := new(string)
		if !r.Keys.Aws.AccessKey.IsUnknown() && !r.Keys.Aws.AccessKey.IsNull() {
			*accessKey = r.Keys.Aws.AccessKey.ValueString()
		} else {
			accessKey = nil
		}
		secretKey := new(string)
		if !r.Keys.Aws.SecretKey.IsUnknown() && !r.Keys.Aws.SecretKey.IsNull() {
			*secretKey = r.Keys.Aws.SecretKey.ValueString()
		} else {
			secretKey = nil
		}
		assumeRoleArn := new(string)
		if !r.Keys.Aws.AssumeRoleArn.IsUnknown() && !r.Keys.Aws.AssumeRoleArn.IsNull() {
			*assumeRoleArn = r.Keys.Aws.AssumeRoleArn.ValueString()
		} else {
			assumeRoleArn = nil
		}
		awsCredentials = &shared.AWSCredentials{
			AccessKey:     accessKey,
			SecretKey:     secretKey,
			AssumeRoleArn: assumeRoleArn,
		}
	}
	if awsCredentials != nil {
		keys = shared.SecurityKeys{
			AWSCredentials: awsCredentials,
		}
	}
	var googleCredentials *shared.GoogleCredentials
	if r.Keys.Google != nil {
		data := new(string)
		if !r.Keys.Google.Data.IsUnknown() && !r.Keys.Google.Data.IsNull() {
			*data = r.Keys.Google.Data.ValueString()
		} else {
			data = nil
		}
		googleCredentials = &shared.GoogleCredentials{
			Data: data,
		}
	}
	if googleCredentials != nil {
		keys = shared.SecurityKeys{
			GoogleCredentials: googleCredentials,
		}
	}
	var gitHubCredentials *shared.GitHubCredentials
	if r.Keys.Github != nil {
		username := new(string)
		if !r.Keys.Github.Username.IsUnknown() && !r.Keys.Github.Username.IsNull() {
			*username = r.Keys.Github.Username.ValueString()
		} else {
			username = nil
		}
		password := new(string)
		if !r.Keys.Github.Password.IsUnknown() && !r.Keys.Github.Password.IsNull() {
			*password = r.Keys.Github.Password.ValueString()
		} else {
			password = nil
		}
		token := new(string)
		if !r.Keys.Github.Token.IsUnknown() && !r.Keys.Github.Token.IsNull() {
			*token = r.Keys.Github.Token.ValueString()
		} else {
			token = nil
		}
		gitHubCredentials = &shared.GitHubCredentials{
			Username: username,
			Password: password,
			Token:    token,
		}
	}
	if gitHubCredentials != nil {
		keys = shared.SecurityKeys{
			GitHubCredentials: gitHubCredentials,
		}
	}
	var gitLabCredentials *shared.GitLabCredentials
	if r.Keys.Gitlab != nil {
		username1 := new(string)
		if !r.Keys.Gitlab.Username.IsUnknown() && !r.Keys.Gitlab.Username.IsNull() {
			*username1 = r.Keys.Gitlab.Username.ValueString()
		} else {
			username1 = nil
		}
		password1 := new(string)
		if !r.Keys.Gitlab.Password.IsUnknown() && !r.Keys.Gitlab.Password.IsNull() {
			*password1 = r.Keys.Gitlab.Password.ValueString()
		} else {
			password1 = nil
		}
		token1 := new(string)
		if !r.Keys.Gitlab.Token.IsUnknown() && !r.Keys.Gitlab.Token.IsNull() {
			*token1 = r.Keys.Gitlab.Token.ValueString()
		} else {
			token1 = nil
		}
		gitLabCredentials = &shared.GitLabCredentials{
			Username: username1,
			Password: password1,
			Token:    token1,
		}
	}
	if gitLabCredentials != nil {
		keys = shared.SecurityKeys{
			GitLabCredentials: gitLabCredentials,
		}
	}
	var bitBucketCredentials *shared.BitBucketCredentials
	if r.Keys.Bitbucket != nil {
		username2 := new(string)
		if !r.Keys.Bitbucket.Username.IsUnknown() && !r.Keys.Bitbucket.Username.IsNull() {
			*username2 = r.Keys.Bitbucket.Username.ValueString()
		} else {
			username2 = nil
		}
		password2 := new(string)
		if !r.Keys.Bitbucket.Password.IsUnknown() && !r.Keys.Bitbucket.Password.IsNull() {
			*password2 = r.Keys.Bitbucket.Password.ValueString()
		} else {
			password2 = nil
		}
		token2 := new(string)
		if !r.Keys.Bitbucket.Token.IsUnknown() && !r.Keys.Bitbucket.Token.IsNull() {
			*token2 = r.Keys.Bitbucket.Token.ValueString()
		} else {
			token2 = nil
		}
		bitBucketCredentials = &shared.BitBucketCredentials{
			Username: username2,
			Password: password2,
			Token:    token2,
		}
	}
	if bitBucketCredentials != nil {
		keys = shared.SecurityKeys{
			BitBucketCredentials: bitBucketCredentials,
		}
	}
	var giteaCredentials *shared.GiteaCredentials
	if r.Keys.Gitea != nil {
		username3 := new(string)
		if !r.Keys.Gitea.Username.IsUnknown() && !r.Keys.Gitea.Username.IsNull() {
			*username3 = r.Keys.Gitea.Username.ValueString()
		} else {
			username3 = nil
		}
		password3 := new(string)
		if !r.Keys.Gitea.Password.IsUnknown() && !r.Keys.Gitea.Password.IsNull() {
			*password3 = r.Keys.Gitea.Password.ValueString()
		} else {
			password3 = nil
		}
		token3 := new(string)
		if !r.Keys.Gitea.Token.IsUnknown() && !r.Keys.Gitea.Token.IsNull() {
			*token3 = r.Keys.Gitea.Token.ValueString()
		} else {
			token3 = nil
		}
		giteaCredentials = &shared.GiteaCredentials{
			Username: username3,
			Password: password3,
			Token:    token3,
		}
	}
	if giteaCredentials != nil {
		keys = shared.SecurityKeys{
			GiteaCredentials: giteaCredentials,
		}
	}
	var sshCredentials *shared.SSHCredentials
	if r.Keys.SSH != nil {
		privateKey := new(string)
		if !r.Keys.SSH.PrivateKey.IsUnknown() && !r.Keys.SSH.PrivateKey.IsNull() {
			*privateKey = r.Keys.SSH.PrivateKey.ValueString()
		} else {
			privateKey = nil
		}
		passphrase := new(string)
		if !r.Keys.SSH.Passphrase.IsUnknown() && !r.Keys.SSH.Passphrase.IsNull() {
			*passphrase = r.Keys.SSH.Passphrase.ValueString()
		} else {
			passphrase = nil
		}
		sshCredentials = &shared.SSHCredentials{
			PrivateKey: privateKey,
			Passphrase: passphrase,
		}
	}
	if sshCredentials != nil {
		keys = shared.SecurityKeys{
			SSHCredentials: sshCredentials,
		}
	}
	var kubernetesCredentials *shared.KubernetesCredentials
	if r.Keys.K8s != nil {
		certificate := new(string)
		if !r.Keys.K8s.Certificate.IsUnknown() && !r.Keys.K8s.Certificate.IsNull() {
			*certificate = r.Keys.K8s.Certificate.ValueString()
		} else {
			certificate = nil
		}
		privateKey1 := new(string)
		if !r.Keys.K8s.PrivateKey.IsUnknown() && !r.Keys.K8s.PrivateKey.IsNull() {
			*privateKey1 = r.Keys.K8s.PrivateKey.ValueString()
		} else {
			privateKey1 = nil
		}
		token4 := new(string)
		if !r.Keys.K8s.Token.IsUnknown() && !r.Keys.K8s.Token.IsNull() {
			*token4 = r.Keys.K8s.Token.ValueString()
		} else {
			token4 = nil
		}
		kubernetesCredentials = &shared.KubernetesCredentials{
			Certificate: certificate,
			PrivateKey:  privateKey1,
			Token:       token4,
		}
	}
	if kubernetesCredentials != nil {
		keys = shared.SecurityKeys{
			KubernetesCredentials: kubernetesCredentials,
		}
	}
	var azureCredentials *shared.AzureCredentials
	if r.Keys.Azure != nil {
		batchName := new(string)
		if !r.Keys.Azure.BatchName.IsUnknown() && !r.Keys.Azure.BatchName.IsNull() {
			*batchName = r.Keys.Azure.BatchName.ValueString()
		} else {
			batchName = nil
		}
		storageName := new(string)
		if !r.Keys.Azure.StorageName.IsUnknown() && !r.Keys.Azure.StorageName.IsNull() {
			*storageName = r.Keys.Azure.StorageName.ValueString()
		} else {
			storageName = nil
		}
		batchKey := new(string)
		if !r.Keys.Azure.BatchKey.IsUnknown() && !r.Keys.Azure.BatchKey.IsNull() {
			*batchKey = r.Keys.Azure.BatchKey.ValueString()
		} else {
			batchKey = nil
		}
		storageKey := new(string)
		if !r.Keys.Azure.StorageKey.IsUnknown() && !r.Keys.Azure.StorageKey.IsNull() {
			*storageKey = r.Keys.Azure.StorageKey.ValueString()
		} else {
			storageKey = nil
		}
		azureCredentials = &shared.AzureCredentials{
			BatchName:   batchName,
			StorageName: storageName,
			BatchKey:    batchKey,
			StorageKey:  storageKey,
		}
	}
	if azureCredentials != nil {
		keys = shared.SecurityKeys{
			AzureCredentials: azureCredentials,
		}
	}
	var azureCloudCredentials *shared.AzureCloudCredentials
	if r.Keys.AzureCloud != nil {
		batchName1 := new(string)
		if !r.Keys.AzureCloud.BatchName.IsUnknown() && !r.Keys.AzureCloud.BatchName.IsNull() {
			*batchName1 = r.Keys.AzureCloud.BatchName.ValueString()
		} else {
			batchName1 = nil
		}
		storageName1 := new(string)
		if !r.Keys.AzureCloud.StorageName.IsUnknown() && !r.Keys.AzureCloud.StorageName.IsNull() {
			*storageName1 = r.Keys.AzureCloud.StorageName.ValueString()
		} else {
			storageName1 = nil
		}
		batchKey1 := new(string)
		if !r.Keys.AzureCloud.BatchKey.IsUnknown() && !r.Keys.AzureCloud.BatchKey.IsNull() {
			*batchKey1 = r.Keys.AzureCloud.BatchKey.ValueString()
		} else {
			batchKey1 = nil
		}
		storageKey1 := new(string)
		if !r.Keys.AzureCloud.StorageKey.IsUnknown() && !r.Keys.AzureCloud.StorageKey.IsNull() {
			*storageKey1 = r.Keys.AzureCloud.StorageKey.ValueString()
		} else {
			storageKey1 = nil
		}
		subscriptionID := new(string)
		if !r.Keys.AzureCloud.SubscriptionID.IsUnknown() && !r.Keys.AzureCloud.SubscriptionID.IsNull() {
			*subscriptionID = r.Keys.AzureCloud.SubscriptionID.ValueString()
		} else {
			subscriptionID = nil
		}
		tenantID := new(string)
		if !r.Keys.AzureCloud.TenantID.IsUnknown() && !r.Keys.AzureCloud.TenantID.IsNull() {
			*tenantID = r.Keys.AzureCloud.TenantID.ValueString()
		} else {
			tenantID = nil
		}
		clientID := new(string)
		if !r.Keys.AzureCloud.ClientID.IsUnknown() && !r.Keys.AzureCloud.ClientID.IsNull() {
			*clientID = r.Keys.AzureCloud.ClientID.ValueString()
		} else {
			clientID = nil
		}
		clientSecret := new(string)
		if !r.Keys.AzureCloud.ClientSecret.IsUnknown() && !r.Keys.AzureCloud.ClientSecret.IsNull() {
			*clientSecret = r.Keys.AzureCloud.ClientSecret.ValueString()
		} else {
			clientSecret = nil
		}
		azureCloudCredentials = &shared.AzureCloudCredentials{
			BatchName:      batchName1,
			StorageName:    storageName1,
			BatchKey:       batchKey1,
			StorageKey:     storageKey1,
			SubscriptionID: subscriptionID,
			TenantID:       tenantID,
			ClientID:       clientID,
			ClientSecret:   clientSecret,
		}
	}
	if azureCloudCredentials != nil {
		keys = shared.SecurityKeys{
			AzureCloudCredentials: azureCloudCredentials,
		}
	}
	var azureReposCredentials *shared.AzureReposCredentials
	if r.Keys.Azurerepos != nil {
		username4 := new(string)
		if !r.Keys.Azurerepos.Username.IsUnknown() && !r.Keys.Azurerepos.Username.IsNull() {
			*username4 = r.Keys.Azurerepos.Username.ValueString()
		} else {
			username4 = nil
		}
		password4 := new(string)
		if !r.Keys.Azurerepos.Password.IsUnknown() && !r.Keys.Azurerepos.Password.IsNull() {
			*password4 = r.Keys.Azurerepos.Password.ValueString()
		} else {
			password4 = nil
		}
		token5 := new(string)
		if !r.Keys.Azurerepos.Token.IsUnknown() && !r.Keys.Azurerepos.Token.IsNull() {
			*token5 = r.Keys.Azurerepos.Token.ValueString()
		} else {
			token5 = nil
		}
		azureReposCredentials = &shared.AzureReposCredentials{
			Username: username4,
			Password: password4,
			Token:    token5,
		}
	}
	if azureReposCredentials != nil {
		keys = shared.SecurityKeys{
			AzureReposCredentials: azureReposCredentials,
		}
	}
	var containerRegistryCredentials *shared.ContainerRegistryCredentials
	if r.Keys.ContainerReg != nil {
		userName := new(string)
		if !r.Keys.ContainerReg.UserName.IsUnknown() && !r.Keys.ContainerReg.UserName.IsNull() {
			*userName = r.Keys.ContainerReg.UserName.ValueString()
		} else {
			userName = nil
		}
		password5 := new(string)
		if !r.Keys.ContainerReg.Password.IsUnknown() && !r.Keys.ContainerReg.Password.IsNull() {
			*password5 = r.Keys.ContainerReg.Password.ValueString()
		} else {
			password5 = nil
		}
		registry := new(string)
		if !r.Keys.ContainerReg.Registry.IsUnknown() && !r.Keys.ContainerReg.Registry.IsNull() {
			*registry = r.Keys.ContainerReg.Registry.ValueString()
		} else {
			registry = nil
		}
		containerRegistryCredentials = &shared.ContainerRegistryCredentials{
			UserName: userName,
			Password: password5,
			Registry: registry,
		}
	}
	if containerRegistryCredentials != nil {
		keys = shared.SecurityKeys{
			ContainerRegistryCredentials: containerRegistryCredentials,
		}
	}
	var towerAgentCredentials *shared.TowerAgentCredentials
	if r.Keys.TwAgent != nil {
		connectionID := new(string)
		if !r.Keys.TwAgent.ConnectionID.IsUnknown() && !r.Keys.TwAgent.ConnectionID.IsNull() {
			*connectionID = r.Keys.TwAgent.ConnectionID.ValueString()
		} else {
			connectionID = nil
		}
		workDir := new(string)
		if !r.Keys.TwAgent.WorkDir.IsUnknown() && !r.Keys.TwAgent.WorkDir.IsNull() {
			*workDir = r.Keys.TwAgent.WorkDir.ValueString()
		} else {
			workDir = nil
		}
		sharedVar := new(bool)
		if !r.Keys.TwAgent.Shared.IsUnknown() && !r.Keys.TwAgent.Shared.IsNull() {
			*sharedVar = r.Keys.TwAgent.Shared.ValueBool()
		} else {
			sharedVar = nil
		}
		towerAgentCredentials = &shared.TowerAgentCredentials{
			ConnectionID: connectionID,
			WorkDir:      workDir,
			Shared:       sharedVar,
		}
	}
	if towerAgentCredentials != nil {
		keys = shared.SecurityKeys{
			TowerAgentCredentials: towerAgentCredentials,
		}
	}
	var awsCodeCommitCredentials *shared.AWSCodeCommitCredentials
	if r.Keys.Codecommit != nil {
		username5 := new(string)
		if !r.Keys.Codecommit.Username.IsUnknown() && !r.Keys.Codecommit.Username.IsNull() {
			*username5 = r.Keys.Codecommit.Username.ValueString()
		} else {
			username5 = nil
		}
		password6 := new(string)
		if !r.Keys.Codecommit.Password.IsUnknown() && !r.Keys.Codecommit.Password.IsNull() {
			*password6 = r.Keys.Codecommit.Password.ValueString()
		} else {
			password6 = nil
		}
		token6 := new(string)
		if !r.Keys.Codecommit.Token.IsUnknown() && !r.Keys.Codecommit.Token.IsNull() {
			*token6 = r.Keys.Codecommit.Token.ValueString()
		} else {
			token6 = nil
		}
		awsCodeCommitCredentials = &shared.AWSCodeCommitCredentials{
			Username: username5,
			Password: password6,
			Token:    token6,
		}
	}
	if awsCodeCommitCredentials != nil {
		keys = shared.SecurityKeys{
			AWSCodeCommitCredentials: awsCodeCommitCredentials,
		}
	}
	var azureEntraCredentials *shared.AzureEntraCredentials
	if r.Keys.AzureEntra != nil {
		batchName2 := new(string)
		if !r.Keys.AzureEntra.BatchName.IsUnknown() && !r.Keys.AzureEntra.BatchName.IsNull() {
			*batchName2 = r.Keys.AzureEntra.BatchName.ValueString()
		} else {
			batchName2 = nil
		}
		storageName2 := new(string)
		if !r.Keys.AzureEntra.StorageName.IsUnknown() && !r.Keys.AzureEntra.StorageName.IsNull() {
			*storageName2 = r.Keys.AzureEntra.StorageName.ValueString()
		} else {
			storageName2 = nil
		}
		batchKey2 := new(string)
		if !r.Keys.AzureEntra.BatchKey.IsUnknown() && !r.Keys.AzureEntra.BatchKey.IsNull() {
			*batchKey2 = r.Keys.AzureEntra.BatchKey.ValueString()
		} else {
			batchKey2 = nil
		}
		storageKey2 := new(string)
		if !r.Keys.AzureEntra.StorageKey.IsUnknown() && !r.Keys.AzureEntra.StorageKey.IsNull() {
			*storageKey2 = r.Keys.AzureEntra.StorageKey.ValueString()
		} else {
			storageKey2 = nil
		}
		tenantId1 := new(string)
		if !r.Keys.AzureEntra.TenantID.IsUnknown() && !r.Keys.AzureEntra.TenantID.IsNull() {
			*tenantId1 = r.Keys.AzureEntra.TenantID.ValueString()
		} else {
			tenantId1 = nil
		}
		clientId1 := new(string)
		if !r.Keys.AzureEntra.ClientID.IsUnknown() && !r.Keys.AzureEntra.ClientID.IsNull() {
			*clientId1 = r.Keys.AzureEntra.ClientID.ValueString()
		} else {
			clientId1 = nil
		}
		clientSecret1 := new(string)
		if !r.Keys.AzureEntra.ClientSecret.IsUnknown() && !r.Keys.AzureEntra.ClientSecret.IsNull() {
			*clientSecret1 = r.Keys.AzureEntra.ClientSecret.ValueString()
		} else {
			clientSecret1 = nil
		}
		azureEntraCredentials = &shared.AzureEntraCredentials{
			BatchName:    batchName2,
			StorageName:  storageName2,
			BatchKey:     batchKey2,
			StorageKey:   storageKey2,
			TenantID:     tenantId1,
			ClientID:     clientId1,
			ClientSecret: clientSecret1,
		}
	}
	if azureEntraCredentials != nil {
		keys = shared.SecurityKeys{
			AzureEntraCredentials: azureEntraCredentials,
		}
	}
	var seqeraComputeCredentials *shared.SeqeraComputeCredentials
	if r.Keys.Seqeracompute != nil {
		accessKey1 := new(string)
		if !r.Keys.Seqeracompute.AccessKey.IsUnknown() && !r.Keys.Seqeracompute.AccessKey.IsNull() {
			*accessKey1 = r.Keys.Seqeracompute.AccessKey.ValueString()
		} else {
			accessKey1 = nil
		}
		secretKey1 := new(string)
		if !r.Keys.Seqeracompute.SecretKey.IsUnknown() && !r.Keys.Seqeracompute.SecretKey.IsNull() {
			*secretKey1 = r.Keys.Seqeracompute.SecretKey.ValueString()
		} else {
			secretKey1 = nil
		}
		assumeRoleArn1 := new(string)
		if !r.Keys.Seqeracompute.AssumeRoleArn.IsUnknown() && !r.Keys.Seqeracompute.AssumeRoleArn.IsNull() {
			*assumeRoleArn1 = r.Keys.Seqeracompute.AssumeRoleArn.ValueString()
		} else {
			assumeRoleArn1 = nil
		}
		seqeraComputeCredentials = &shared.SeqeraComputeCredentials{
			AccessKey:     accessKey1,
			SecretKey:     secretKey1,
			AssumeRoleArn: assumeRoleArn1,
		}
	}
	if seqeraComputeCredentials != nil {
		keys = shared.SecurityKeys{
			SeqeraComputeCredentials: seqeraComputeCredentials,
		}
	}
	var s3CompatibleCredentials *shared.S3CompatibleCredentials
	if r.Keys.S3 != nil {
		accessKey2 := new(string)
		if !r.Keys.S3.AccessKey.IsUnknown() && !r.Keys.S3.AccessKey.IsNull() {
			*accessKey2 = r.Keys.S3.AccessKey.ValueString()
		} else {
			accessKey2 = nil
		}
		secretKey2 := new(string)
		if !r.Keys.S3.SecretKey.IsUnknown() && !r.Keys.S3.SecretKey.IsNull() {
			*secretKey2 = r.Keys.S3.SecretKey.ValueString()
		} else {
			secretKey2 = nil
		}
		pathStyleAccessEnabled := new(bool)
		if !r.Keys.S3.PathStyleAccessEnabled.IsUnknown() && !r.Keys.S3.PathStyleAccessEnabled.IsNull() {
			*pathStyleAccessEnabled = r.Keys.S3.PathStyleAccessEnabled.ValueBool()
		} else {
			pathStyleAccessEnabled = nil
		}
		s3CompatibleCredentials = &shared.S3CompatibleCredentials{
			AccessKey:              accessKey2,
			SecretKey:              secretKey2,
			PathStyleAccessEnabled: pathStyleAccessEnabled,
		}
	}
	if s3CompatibleCredentials != nil {
		keys = shared.SecurityKeys{
			S3CompatibleCredentials: s3CompatibleCredentials,
		}
	}
	var localSecurityKeys *shared.LocalSecurityKeys
	if r.Keys.Local != nil {
		password7 := new(string)
		if !r.Keys.Local.Password.IsUnknown() && !r.Keys.Local.Password.IsNull() {
			*password7 = r.Keys.Local.Password.ValueString()
		} else {
			password7 = nil
		}
		localSecurityKeys = &shared.LocalSecurityKeys{
			Password: password7,
		}
	}
	if localSecurityKeys != nil {
		keys = shared.SecurityKeys{
			LocalSecurityKeys: localSecurityKeys,
		}
	}
	out := shared.CredentialsInput{
		ID:           id,
		Name:         name,
		Description:  description,
		ProviderType: providerType,
		BaseURL:      baseURL,
		Category:     category,
		Keys:         keys,
	}

	return &out, diags
}

func (r *CredentialResourceModel) ToSharedUpdateCredentialsRequest(ctx context.Context) (*shared.UpdateCredentialsRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	credentials, credentialsDiags := r.ToSharedCredentialsInput(ctx)
	diags.Append(credentialsDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := shared.UpdateCredentialsRequest{
		Credentials: credentials,
	}

	return &out, diags
}
