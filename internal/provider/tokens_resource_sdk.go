// Code generated by Speakeasy (https://speakeasy.com). MANUALLY MODIFIED.
// This file has been manually modified to fix token filtering by ID.
// It is protected from regeneration via .genignore.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/seqeralabs/terraform-provider-seqera/internal/provider/typeconvert"
	tfTypes "github.com/seqeralabs/terraform-provider-seqera/internal/provider/types"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/models/operations"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/models/shared"
)

func (r *TokensResourceModel) RefreshFromSharedAccessToken(ctx context.Context, resp *shared.AccessToken) diag.Diagnostics {
	var diags diag.Diagnostics

	r.DateCreated = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.DateCreated))
	r.ID = types.Int64PointerValue(resp.ID)
	r.LastUsed = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.LastUsed))
	r.Name = types.StringValue(resp.Name)

	return diags
}

func (r *TokensResourceModel) RefreshFromSharedCreateAccessTokenResponse(ctx context.Context, resp *shared.CreateAccessTokenResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.AccessKey = types.StringPointerValue(resp.AccessKey)
		if resp.Token == nil {
			r.Token = nil
		} else {
			r.Token = &tfTypes.AccessToken{}
			r.Token.DateCreated = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Token.DateCreated))
			r.Token.ID = types.Int64PointerValue(resp.Token.ID)
			r.Token.LastUsed = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Token.LastUsed))
			r.Token.Name = types.StringValue(resp.Token.Name)

			// MANUAL FIX: Also populate top-level entity fields from the nested token object
			// This ensures r.ID is set before TokenList filtering occurs
			r.ID = types.Int64PointerValue(resp.Token.ID)
			r.Name = types.StringValue(resp.Token.Name)
			r.DateCreated = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Token.DateCreated))
			r.LastUsed = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Token.LastUsed))
		}
	}

	return diags
}

func (r *TokensResourceModel) RefreshFromSharedListAccessTokensResponse(ctx context.Context, resp *shared.ListAccessTokensResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		// If no tokens returned, mark as not found by setting ID to null
		// The generated Read function checks for null ID and removes from state
		if len(resp.Tokens) == 0 {
			r.ID = types.Int64Null()
			return diags
		}

		// Find the token matching this resource's ID
		var matchingToken *shared.AccessToken
		currentID := r.ID.ValueInt64()

		for i := range resp.Tokens {
			token := &resp.Tokens[i]
			if token.ID != nil && *token.ID == currentID {
				matchingToken = token
				break
			}
		}

		// If token with this ID not found in the list, mark as not found
		if matchingToken == nil {
			r.ID = types.Int64Null()
			return diags
		}

		diags.Append(r.RefreshFromSharedAccessToken(ctx, matchingToken)...)

		if diags.HasError() {
			return diags
		}

	}

	return diags
}

func (r *TokensResourceModel) ToOperationsDeleteTokenRequest(ctx context.Context) (*operations.DeleteTokenRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	tokenID := r.ID.ValueInt64()

	out := operations.DeleteTokenRequest{
		TokenID: tokenID,
	}

	return &out, diags
}

func (r *TokensResourceModel) ToSharedCreateAccessTokenRequest(ctx context.Context) (*shared.CreateAccessTokenRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	name := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name = r.Name.ValueString()
	} else {
		name = nil
	}
	out := shared.CreateAccessTokenRequest{
		Name: name,
	}

	return &out, diags
}
