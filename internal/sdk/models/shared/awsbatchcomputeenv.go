// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/internal/utils"
	"time"
)

// ForgeType - Type of compute instances to provision:
// - SPOT: Use EC2 Spot instances (cost-effective, can be interrupted)
// - EC2: Use On-Demand EC2 instances (reliable, higher cost)
// - FARGATE: Use AWS Fargate serverless compute
type ForgeType string

const (
	ForgeTypeSpot    ForgeType = "SPOT"
	ForgeTypeEc2     ForgeType = "EC2"
	ForgeTypeFargate ForgeType = "FARGATE"
)

func (e ForgeType) ToPointer() *ForgeType {
	return &e
}
func (e *ForgeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SPOT":
		fallthrough
	case "EC2":
		fallthrough
	case "FARGATE":
		*e = ForgeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ForgeType: %v", v)
	}
}

// AllocationStrategy - Strategy for allocating compute resources.
// SPOT_CAPACITY_OPTIMIZED only valid when forge_type is SPOT.
type AllocationStrategy string

const (
	AllocationStrategyBestFit                    AllocationStrategy = "BEST_FIT"
	AllocationStrategyBestFitProgressive         AllocationStrategy = "BEST_FIT_PROGRESSIVE"
	AllocationStrategySpotCapacityOptimized      AllocationStrategy = "SPOT_CAPACITY_OPTIMIZED"
	AllocationStrategySpotPriceCapacityOptimized AllocationStrategy = "SPOT_PRICE_CAPACITY_OPTIMIZED"
)

func (e AllocationStrategy) ToPointer() *AllocationStrategy {
	return &e
}
func (e *AllocationStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BEST_FIT":
		fallthrough
	case "BEST_FIT_PROGRESSIVE":
		fallthrough
	case "SPOT_CAPACITY_OPTIMIZED":
		fallthrough
	case "SPOT_PRICE_CAPACITY_OPTIMIZED":
		*e = AllocationStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllocationStrategy: %v", v)
	}
}

// AWS Forge configuration for compute resources
type Forge struct {
	// Type of compute instances to provision:
	// - SPOT: Use EC2 Spot instances (cost-effective, can be interrupted)
	// - EC2: Use On-Demand EC2 instances (reliable, higher cost)
	// - FARGATE: Use AWS Fargate serverless compute
	//
	ForgeType *ForgeType `default:"EC2" json:"type"`
	// Minimum number of CPUs to maintain in the compute environment.
	// Setting to 0 allows environment to scale to zero when idle.
	//
	MinCpus *int `default:"0" json:"minCpus"`
	// Maximum number of CPUs available in the compute environment.
	// Subject to AWS service quotas.
	//
	MaxCpus *int `default:"256" json:"maxCpus"`
	// Enable GPU support for compute instances.
	// When enabled, GPU-capable instance types will be selected.
	//
	GpuEnabled *bool `default:"false" json:"gpuEnabled"`
	// List of EC2 instance types to use.
	// Examples: ["m5.xlarge", "m5.2xlarge"], ["c5.2xlarge"], ["p3.2xlarge"]
	// Default: ["optimal"] - AWS Batch selects appropriate instances
	//
	InstanceTypes []string `json:"instanceTypes,omitempty"`
	// Strategy for allocating compute resources.
	// SPOT_CAPACITY_OPTIMIZED only valid when forge_type is SPOT.
	//
	AllocationStrategy *AllocationStrategy `json:"allocStrategy,omitempty"`
	// Maximum percentage of On-Demand price to pay for Spot instances (0-100).
	// Only applicable when forge_type is SPOT.
	//
	BidPercentage *int `json:"bidPercentage,omitempty"`
	// Enable automatic EBS volume expansion
	EbsAutoScale *bool `default:"false" json:"ebsAutoScale"`
	// Size of EBS root volume in GB (minimum 8 GB, maximum 16 TB)
	EbsBlockSize *int `default:"50" json:"ebsBlockSize"`
	// VPC ID where compute environment will be deployed.
	// Format: vpc- followed by hexadecimal characters
	//
	VpcID *string `json:"vpcId,omitempty"`
	// List of subnet IDs for compute instances.
	// Subnets must be in the specified VPC. Use multiple subnets for high availability.
	//
	Subnets []string `json:"subnets,omitempty"`
	// List of security group IDs to attach to compute instances
	SecurityGroups []string `json:"securityGroups,omitempty"`
	// EC2 key pair name for SSH access to compute instances
	Ec2KeyPair *string `json:"ec2KeyPair,omitempty"`
	// Dispose of AWS Batch resources when compute environment is deleted
	//
	DisposeOnDeletion *bool `default:"true" json:"disposeOnDeletion"`
	// Use Fargate for head job instead of EC2.
	// Reduces costs by running head job on serverless compute.
	//
	FargateHeadEnabled *bool `default:"false" json:"fargateHeadEnabled"`
	// Automatically create an EFS file system
	EfsCreate *bool `default:"false" json:"efsCreate"`
	// EFS file system ID to mount.
	// Format: fs- followed by hexadecimal characters
	//
	EfsID *string `json:"efsId,omitempty"`
	// Path where EFS will be mounted in the container
	EfsMount *string `default:"/mnt/efs" json:"efsMount"`
	// FSx for Lustre file system name
	FsxName *string `json:"fsxName,omitempty"`
	// Path where FSx will be mounted in the container
	FsxMount *string `default:"/fsx" json:"fsxMount"`
	// Size of FSx file system in GB
	FsxSize *int `json:"fsxSize,omitempty"`
}

func (f Forge) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Forge) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *Forge) GetForgeType() *ForgeType {
	if f == nil {
		return nil
	}
	return f.ForgeType
}

func (f *Forge) GetMinCpus() *int {
	if f == nil {
		return nil
	}
	return f.MinCpus
}

func (f *Forge) GetMaxCpus() *int {
	if f == nil {
		return nil
	}
	return f.MaxCpus
}

func (f *Forge) GetGpuEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.GpuEnabled
}

func (f *Forge) GetInstanceTypes() []string {
	if f == nil {
		return nil
	}
	return f.InstanceTypes
}

func (f *Forge) GetAllocationStrategy() *AllocationStrategy {
	if f == nil {
		return nil
	}
	return f.AllocationStrategy
}

func (f *Forge) GetBidPercentage() *int {
	if f == nil {
		return nil
	}
	return f.BidPercentage
}

func (f *Forge) GetEbsAutoScale() *bool {
	if f == nil {
		return nil
	}
	return f.EbsAutoScale
}

func (f *Forge) GetEbsBlockSize() *int {
	if f == nil {
		return nil
	}
	return f.EbsBlockSize
}

func (f *Forge) GetVpcID() *string {
	if f == nil {
		return nil
	}
	return f.VpcID
}

func (f *Forge) GetSubnets() []string {
	if f == nil {
		return nil
	}
	return f.Subnets
}

func (f *Forge) GetSecurityGroups() []string {
	if f == nil {
		return nil
	}
	return f.SecurityGroups
}

func (f *Forge) GetEc2KeyPair() *string {
	if f == nil {
		return nil
	}
	return f.Ec2KeyPair
}

func (f *Forge) GetDisposeOnDeletion() *bool {
	if f == nil {
		return nil
	}
	return f.DisposeOnDeletion
}

func (f *Forge) GetFargateHeadEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.FargateHeadEnabled
}

func (f *Forge) GetEfsCreate() *bool {
	if f == nil {
		return nil
	}
	return f.EfsCreate
}

func (f *Forge) GetEfsID() *string {
	if f == nil {
		return nil
	}
	return f.EfsID
}

func (f *Forge) GetEfsMount() *string {
	if f == nil {
		return nil
	}
	return f.EfsMount
}

func (f *Forge) GetFsxName() *string {
	if f == nil {
		return nil
	}
	return f.FsxName
}

func (f *Forge) GetFsxMount() *string {
	if f == nil {
		return nil
	}
	return f.FsxMount
}

func (f *Forge) GetFsxSize() *int {
	if f == nil {
		return nil
	}
	return f.FsxSize
}

type Config struct {
	// Name of the AWS Batch compute queue
	ComputeQueue *string `json:"computeQueue,omitempty"`
	// Name of the head job queue
	HeadQueue *string `json:"headQueue,omitempty"`
	// Bash script to run before workflow execution begins.
	// Use for environment setup, loading modules, etc.
	//
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Bash script to run after workflow execution completes.
	// Use for cleanup, archiving results, etc.
	//
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Path to AWS CLI on compute instances
	CliPath *string `default:"/home/ec2-user/miniconda/bin/aws" json:"cliPath"`
	// IAM role ARN for Batch execution (pulling container images, writing logs).
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ExecutionRole *string `json:"executionRole,omitempty"`
	// IAM role ARN for compute jobs. Jobs assume this role during execution.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ComputeJobRole *string `json:"computeJobRole,omitempty"`
	// IAM role ARN for the head job
	HeadJobRole *string `json:"headJobRole,omitempty"`
	// Number of CPUs allocated for the head job
	HeadJobCpus *int `default:"1" json:"headJobCpus"`
	// Memory allocation for the head job in MB
	HeadJobMemoryMb *int `default:"1024" json:"headJobMemoryMb"`
	// Enable Fusion v2 for virtual file system. Fusion provides virtual file system
	// for efficient S3 access and improves performance by lazy loading files.
	//
	EnableFusion *bool `default:"false" json:"fusion2Enabled"`
	// Enable Wave containers service. Wave builds and manages container images on-demand.
	// When enable_wave is true, enable_fusion must be explicitly set.
	//
	EnableWave *bool `default:"false" json:"waveEnabled"`
	// AWS Forge configuration for compute resources
	Forge *Forge `json:"forge,omitempty"`
}

func (c Config) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Config) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *Config) GetComputeQueue() *string {
	if c == nil {
		return nil
	}
	return c.ComputeQueue
}

func (c *Config) GetHeadQueue() *string {
	if c == nil {
		return nil
	}
	return c.HeadQueue
}

func (c *Config) GetPreRunScript() *string {
	if c == nil {
		return nil
	}
	return c.PreRunScript
}

func (c *Config) GetPostRunScript() *string {
	if c == nil {
		return nil
	}
	return c.PostRunScript
}

func (c *Config) GetCliPath() *string {
	if c == nil {
		return nil
	}
	return c.CliPath
}

func (c *Config) GetExecutionRole() *string {
	if c == nil {
		return nil
	}
	return c.ExecutionRole
}

func (c *Config) GetComputeJobRole() *string {
	if c == nil {
		return nil
	}
	return c.ComputeJobRole
}

func (c *Config) GetHeadJobRole() *string {
	if c == nil {
		return nil
	}
	return c.HeadJobRole
}

func (c *Config) GetHeadJobCpus() *int {
	if c == nil {
		return nil
	}
	return c.HeadJobCpus
}

func (c *Config) GetHeadJobMemoryMb() *int {
	if c == nil {
		return nil
	}
	return c.HeadJobMemoryMb
}

func (c *Config) GetEnableFusion() *bool {
	if c == nil {
		return nil
	}
	return c.EnableFusion
}

func (c *Config) GetEnableWave() *bool {
	if c == nil {
		return nil
	}
	return c.EnableWave
}

func (c *Config) GetForge() *Forge {
	if c == nil {
		return nil
	}
	return c.Forge
}

type AWSBatchComputeEnv struct {
	// Unique identifier for the compute environment
	ComputeEnvID *string `json:"id,omitempty"`
	// Current status of the compute environment
	Status *string `json:"status,omitempty"`
	// Status message or error details
	Message *string `json:"message,omitempty"`
	// Timestamp when the compute environment was created
	DateCreated *time.Time `json:"dateCreated,omitempty"`
	// Timestamp when the compute environment was last modified
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`
	// Flag indicating if the compute environment has been deleted
	Deleted *bool `json:"deleted,omitempty"`
	// Display name for the compute environment (max 100 characters)
	Name string `json:"name"`
	// AWS credentials ID to use for accessing AWS services
	CredentialsID string `json:"credentialsId"`
	// AWS region where the Batch compute environment will be created.
	// Examples: us-east-1, eu-west-1, ap-southeast-2
	//
	Region string `json:"region"`
	// S3 bucket path for Nextflow work directory where intermediate files will be stored.
	// Format: s3://bucket-name/path
	// Example: s3://my-nextflow-bucket/work
	//
	WorkDirectory string `json:"workDir"`
	// Workspace numeric identifier where the compute environment will be created
	WorkspaceID *int64 `json:"workspaceId,omitempty"`
	// Optional description of the compute environment
	Description *string `json:"description,omitempty"`
	Config      *Config `json:"config,omitempty"`
}

func (a AWSBatchComputeEnv) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSBatchComputeEnv) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"name", "credentialsId", "region", "workDir"}); err != nil {
		return err
	}
	return nil
}

func (a *AWSBatchComputeEnv) GetComputeEnvID() *string {
	if a == nil {
		return nil
	}
	return a.ComputeEnvID
}

func (a *AWSBatchComputeEnv) GetStatus() *string {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *AWSBatchComputeEnv) GetMessage() *string {
	if a == nil {
		return nil
	}
	return a.Message
}

func (a *AWSBatchComputeEnv) GetDateCreated() *time.Time {
	if a == nil {
		return nil
	}
	return a.DateCreated
}

func (a *AWSBatchComputeEnv) GetLastUpdated() *time.Time {
	if a == nil {
		return nil
	}
	return a.LastUpdated
}

func (a *AWSBatchComputeEnv) GetDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.Deleted
}

func (a *AWSBatchComputeEnv) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AWSBatchComputeEnv) GetCredentialsID() string {
	if a == nil {
		return ""
	}
	return a.CredentialsID
}

func (a *AWSBatchComputeEnv) GetRegion() string {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AWSBatchComputeEnv) GetWorkDirectory() string {
	if a == nil {
		return ""
	}
	return a.WorkDirectory
}

func (a *AWSBatchComputeEnv) GetWorkspaceID() *int64 {
	if a == nil {
		return nil
	}
	return a.WorkspaceID
}

func (a *AWSBatchComputeEnv) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *AWSBatchComputeEnv) GetConfig() *Config {
	if a == nil {
		return nil
	}
	return a.Config
}
