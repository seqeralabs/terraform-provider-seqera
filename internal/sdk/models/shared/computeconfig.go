// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/internal/utils"
)

type MoabConfiguration struct {
	// Working directory path for workflow execution
	WorkDir string `json:"workDir"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	LaunchDir               *string `json:"launchDir,omitempty"`
	UserName                *string `json:"userName,omitempty"`
	HostName                *string `json:"hostName,omitempty"`
	Port                    *int    `json:"port,omitempty"`
	HeadQueue               *string `json:"headQueue,omitempty"`
	ComputeQueue            *string `json:"computeQueue,omitempty"`
	MaxQueueSize            *int    `json:"maxQueueSize,omitempty"`
	HeadJobOptions          *string `json:"headJobOptions,omitempty"`
	PropagateHeadJobOptions *bool   `json:"propagateHeadJobOptions,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (m MoabConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MoabConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"workDir"}); err != nil {
		return err
	}
	return nil
}

func (m *MoabConfiguration) GetWorkDir() string {
	if m == nil {
		return ""
	}
	return m.WorkDir
}

func (m *MoabConfiguration) GetPreRunScript() *string {
	if m == nil {
		return nil
	}
	return m.PreRunScript
}

func (m *MoabConfiguration) GetPostRunScript() *string {
	if m == nil {
		return nil
	}
	return m.PostRunScript
}

func (m *MoabConfiguration) GetNextflowConfig() *string {
	if m == nil {
		return nil
	}
	return m.NextflowConfig
}

func (m *MoabConfiguration) GetLaunchDir() *string {
	if m == nil {
		return nil
	}
	return m.LaunchDir
}

func (m *MoabConfiguration) GetUserName() *string {
	if m == nil {
		return nil
	}
	return m.UserName
}

func (m *MoabConfiguration) GetHostName() *string {
	if m == nil {
		return nil
	}
	return m.HostName
}

func (m *MoabConfiguration) GetPort() *int {
	if m == nil {
		return nil
	}
	return m.Port
}

func (m *MoabConfiguration) GetHeadQueue() *string {
	if m == nil {
		return nil
	}
	return m.HeadQueue
}

func (m *MoabConfiguration) GetComputeQueue() *string {
	if m == nil {
		return nil
	}
	return m.ComputeQueue
}

func (m *MoabConfiguration) GetMaxQueueSize() *int {
	if m == nil {
		return nil
	}
	return m.MaxQueueSize
}

func (m *MoabConfiguration) GetHeadJobOptions() *string {
	if m == nil {
		return nil
	}
	return m.HeadJobOptions
}

func (m *MoabConfiguration) GetPropagateHeadJobOptions() *bool {
	if m == nil {
		return nil
	}
	return m.PropagateHeadJobOptions
}

func (m *MoabConfiguration) GetDiscriminator() *string {
	if m == nil {
		return nil
	}
	return m.Discriminator
}

func (m *MoabConfiguration) GetEnvironment() []ConfigEnvVariable {
	if m == nil {
		return nil
	}
	return m.Environment
}

type AltairPBSConfiguration struct {
	// Working directory path for workflow execution
	WorkDir string `json:"workDir"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	LaunchDir               *string `json:"launchDir,omitempty"`
	UserName                *string `json:"userName,omitempty"`
	HostName                *string `json:"hostName,omitempty"`
	Port                    *int    `json:"port,omitempty"`
	HeadQueue               *string `json:"headQueue,omitempty"`
	ComputeQueue            *string `json:"computeQueue,omitempty"`
	MaxQueueSize            *int    `json:"maxQueueSize,omitempty"`
	HeadJobOptions          *string `json:"headJobOptions,omitempty"`
	PropagateHeadJobOptions *bool   `json:"propagateHeadJobOptions,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (a AltairPBSConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AltairPBSConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"workDir"}); err != nil {
		return err
	}
	return nil
}

func (a *AltairPBSConfiguration) GetWorkDir() string {
	if a == nil {
		return ""
	}
	return a.WorkDir
}

func (a *AltairPBSConfiguration) GetPreRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PreRunScript
}

func (a *AltairPBSConfiguration) GetPostRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PostRunScript
}

func (a *AltairPBSConfiguration) GetNextflowConfig() *string {
	if a == nil {
		return nil
	}
	return a.NextflowConfig
}

func (a *AltairPBSConfiguration) GetLaunchDir() *string {
	if a == nil {
		return nil
	}
	return a.LaunchDir
}

func (a *AltairPBSConfiguration) GetUserName() *string {
	if a == nil {
		return nil
	}
	return a.UserName
}

func (a *AltairPBSConfiguration) GetHostName() *string {
	if a == nil {
		return nil
	}
	return a.HostName
}

func (a *AltairPBSConfiguration) GetPort() *int {
	if a == nil {
		return nil
	}
	return a.Port
}

func (a *AltairPBSConfiguration) GetHeadQueue() *string {
	if a == nil {
		return nil
	}
	return a.HeadQueue
}

func (a *AltairPBSConfiguration) GetComputeQueue() *string {
	if a == nil {
		return nil
	}
	return a.ComputeQueue
}

func (a *AltairPBSConfiguration) GetMaxQueueSize() *int {
	if a == nil {
		return nil
	}
	return a.MaxQueueSize
}

func (a *AltairPBSConfiguration) GetHeadJobOptions() *string {
	if a == nil {
		return nil
	}
	return a.HeadJobOptions
}

func (a *AltairPBSConfiguration) GetPropagateHeadJobOptions() *bool {
	if a == nil {
		return nil
	}
	return a.PropagateHeadJobOptions
}

func (a *AltairPBSConfiguration) GetDiscriminator() *string {
	if a == nil {
		return nil
	}
	return a.Discriminator
}

func (a *AltairPBSConfiguration) GetEnvironment() []ConfigEnvVariable {
	if a == nil {
		return nil
	}
	return a.Environment
}

type UnivaGridEngineConfiguration struct {
	// Working directory path for workflow execution
	WorkDir string `json:"workDir"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	LaunchDir               *string `json:"launchDir,omitempty"`
	UserName                *string `json:"userName,omitempty"`
	HostName                *string `json:"hostName,omitempty"`
	Port                    *int    `json:"port,omitempty"`
	HeadQueue               *string `json:"headQueue,omitempty"`
	ComputeQueue            *string `json:"computeQueue,omitempty"`
	MaxQueueSize            *int    `json:"maxQueueSize,omitempty"`
	HeadJobOptions          *string `json:"headJobOptions,omitempty"`
	PropagateHeadJobOptions *bool   `json:"propagateHeadJobOptions,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (u UnivaGridEngineConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UnivaGridEngineConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"workDir"}); err != nil {
		return err
	}
	return nil
}

func (u *UnivaGridEngineConfiguration) GetWorkDir() string {
	if u == nil {
		return ""
	}
	return u.WorkDir
}

func (u *UnivaGridEngineConfiguration) GetPreRunScript() *string {
	if u == nil {
		return nil
	}
	return u.PreRunScript
}

func (u *UnivaGridEngineConfiguration) GetPostRunScript() *string {
	if u == nil {
		return nil
	}
	return u.PostRunScript
}

func (u *UnivaGridEngineConfiguration) GetNextflowConfig() *string {
	if u == nil {
		return nil
	}
	return u.NextflowConfig
}

func (u *UnivaGridEngineConfiguration) GetLaunchDir() *string {
	if u == nil {
		return nil
	}
	return u.LaunchDir
}

func (u *UnivaGridEngineConfiguration) GetUserName() *string {
	if u == nil {
		return nil
	}
	return u.UserName
}

func (u *UnivaGridEngineConfiguration) GetHostName() *string {
	if u == nil {
		return nil
	}
	return u.HostName
}

func (u *UnivaGridEngineConfiguration) GetPort() *int {
	if u == nil {
		return nil
	}
	return u.Port
}

func (u *UnivaGridEngineConfiguration) GetHeadQueue() *string {
	if u == nil {
		return nil
	}
	return u.HeadQueue
}

func (u *UnivaGridEngineConfiguration) GetComputeQueue() *string {
	if u == nil {
		return nil
	}
	return u.ComputeQueue
}

func (u *UnivaGridEngineConfiguration) GetMaxQueueSize() *int {
	if u == nil {
		return nil
	}
	return u.MaxQueueSize
}

func (u *UnivaGridEngineConfiguration) GetHeadJobOptions() *string {
	if u == nil {
		return nil
	}
	return u.HeadJobOptions
}

func (u *UnivaGridEngineConfiguration) GetPropagateHeadJobOptions() *bool {
	if u == nil {
		return nil
	}
	return u.PropagateHeadJobOptions
}

func (u *UnivaGridEngineConfiguration) GetDiscriminator() *string {
	if u == nil {
		return nil
	}
	return u.Discriminator
}

func (u *UnivaGridEngineConfiguration) GetEnvironment() []ConfigEnvVariable {
	if u == nil {
		return nil
	}
	return u.Environment
}

type GoogleGKEClusterConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript         *string           `json:"postRunScript,omitempty"`
	Server                string            `json:"server"`
	SslCert               string            `json:"sslCert"`
	Namespace             string            `json:"namespace"`
	ComputeServiceAccount *string           `json:"computeServiceAccount,omitempty"`
	HeadServiceAccount    string            `json:"headServiceAccount"`
	StorageClaimName      string            `json:"storageClaimName"`
	StorageMountPath      *string           `json:"storageMountPath,omitempty"`
	PodCleanup            *PodCleanupPolicy `json:"podCleanup,omitempty"`
	HeadPodSpec           *string           `json:"headPodSpec,omitempty"`
	ServicePodSpec        *string           `json:"servicePodSpec,omitempty"`
	// Array of environment variables for the compute environment
	Environment     []ConfigEnvVariable `json:"environment,omitempty"`
	HeadJobCpus     *int                `json:"headJobCpus,omitempty"`
	HeadJobMemoryMb *int                `json:"headJobMemoryMb,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
	// The GKE cluster region - or - zone
	Region string `json:"region"`
	// The GKE cluster name
	ClusterName  string `json:"clusterName"`
	EnableFusion *bool  `json:"fusion2Enabled,omitempty"`
	EnableWave   *bool  `json:"waveEnabled,omitempty"`
}

func (g GoogleGKEClusterConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GoogleGKEClusterConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"server", "sslCert", "namespace", "headServiceAccount", "storageClaimName", "region", "clusterName"}); err != nil {
		return err
	}
	return nil
}

func (g *GoogleGKEClusterConfiguration) GetDiscriminator() *string {
	if g == nil {
		return nil
	}
	return g.Discriminator
}

func (g *GoogleGKEClusterConfiguration) GetWorkDir() *string {
	if g == nil {
		return nil
	}
	return g.WorkDir
}

func (g *GoogleGKEClusterConfiguration) GetPreRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PreRunScript
}

func (g *GoogleGKEClusterConfiguration) GetPostRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PostRunScript
}

func (g *GoogleGKEClusterConfiguration) GetServer() string {
	if g == nil {
		return ""
	}
	return g.Server
}

func (g *GoogleGKEClusterConfiguration) GetSslCert() string {
	if g == nil {
		return ""
	}
	return g.SslCert
}

func (g *GoogleGKEClusterConfiguration) GetNamespace() string {
	if g == nil {
		return ""
	}
	return g.Namespace
}

func (g *GoogleGKEClusterConfiguration) GetComputeServiceAccount() *string {
	if g == nil {
		return nil
	}
	return g.ComputeServiceAccount
}

func (g *GoogleGKEClusterConfiguration) GetHeadServiceAccount() string {
	if g == nil {
		return ""
	}
	return g.HeadServiceAccount
}

func (g *GoogleGKEClusterConfiguration) GetStorageClaimName() string {
	if g == nil {
		return ""
	}
	return g.StorageClaimName
}

func (g *GoogleGKEClusterConfiguration) GetStorageMountPath() *string {
	if g == nil {
		return nil
	}
	return g.StorageMountPath
}

func (g *GoogleGKEClusterConfiguration) GetPodCleanup() *PodCleanupPolicy {
	if g == nil {
		return nil
	}
	return g.PodCleanup
}

func (g *GoogleGKEClusterConfiguration) GetHeadPodSpec() *string {
	if g == nil {
		return nil
	}
	return g.HeadPodSpec
}

func (g *GoogleGKEClusterConfiguration) GetServicePodSpec() *string {
	if g == nil {
		return nil
	}
	return g.ServicePodSpec
}

func (g *GoogleGKEClusterConfiguration) GetEnvironment() []ConfigEnvVariable {
	if g == nil {
		return nil
	}
	return g.Environment
}

func (g *GoogleGKEClusterConfiguration) GetHeadJobCpus() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobCpus
}

func (g *GoogleGKEClusterConfiguration) GetHeadJobMemoryMb() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobMemoryMb
}

func (g *GoogleGKEClusterConfiguration) GetNextflowConfig() *string {
	if g == nil {
		return nil
	}
	return g.NextflowConfig
}

func (g *GoogleGKEClusterConfiguration) GetRegion() string {
	if g == nil {
		return ""
	}
	return g.Region
}

func (g *GoogleGKEClusterConfiguration) GetClusterName() string {
	if g == nil {
		return ""
	}
	return g.ClusterName
}

func (g *GoogleGKEClusterConfiguration) GetEnableFusion() *bool {
	if g == nil {
		return nil
	}
	return g.EnableFusion
}

func (g *GoogleGKEClusterConfiguration) GetEnableWave() *bool {
	if g == nil {
		return nil
	}
	return g.EnableWave
}

type AmazonEKSClusterConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript         *string           `json:"postRunScript,omitempty"`
	Server                string            `json:"server"`
	SslCert               string            `json:"sslCert"`
	Namespace             string            `json:"namespace"`
	ComputeServiceAccount *string           `json:"computeServiceAccount,omitempty"`
	HeadServiceAccount    string            `json:"headServiceAccount"`
	StorageClaimName      string            `json:"storageClaimName"`
	StorageMountPath      *string           `json:"storageMountPath,omitempty"`
	PodCleanup            *PodCleanupPolicy `json:"podCleanup,omitempty"`
	HeadPodSpec           *string           `json:"headPodSpec,omitempty"`
	ServicePodSpec        *string           `json:"servicePodSpec,omitempty"`
	// Array of environment variables for the compute environment
	Environment     []ConfigEnvVariable `json:"environment,omitempty"`
	HeadJobCpus     *int                `json:"headJobCpus,omitempty"`
	HeadJobMemoryMb *int                `json:"headJobMemoryMb,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
	// AWS region
	Region string `json:"region"`
	// The AWS EKS cluster name
	ClusterName  string `json:"clusterName"`
	EnableWave   *bool  `json:"waveEnabled,omitempty"`
	EnableFusion *bool  `json:"fusion2Enabled,omitempty"`
}

func (a AmazonEKSClusterConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmazonEKSClusterConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"server", "sslCert", "namespace", "headServiceAccount", "storageClaimName", "region", "clusterName"}); err != nil {
		return err
	}
	return nil
}

func (a *AmazonEKSClusterConfiguration) GetDiscriminator() *string {
	if a == nil {
		return nil
	}
	return a.Discriminator
}

func (a *AmazonEKSClusterConfiguration) GetWorkDir() *string {
	if a == nil {
		return nil
	}
	return a.WorkDir
}

func (a *AmazonEKSClusterConfiguration) GetPreRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PreRunScript
}

func (a *AmazonEKSClusterConfiguration) GetPostRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PostRunScript
}

func (a *AmazonEKSClusterConfiguration) GetServer() string {
	if a == nil {
		return ""
	}
	return a.Server
}

func (a *AmazonEKSClusterConfiguration) GetSslCert() string {
	if a == nil {
		return ""
	}
	return a.SslCert
}

func (a *AmazonEKSClusterConfiguration) GetNamespace() string {
	if a == nil {
		return ""
	}
	return a.Namespace
}

func (a *AmazonEKSClusterConfiguration) GetComputeServiceAccount() *string {
	if a == nil {
		return nil
	}
	return a.ComputeServiceAccount
}

func (a *AmazonEKSClusterConfiguration) GetHeadServiceAccount() string {
	if a == nil {
		return ""
	}
	return a.HeadServiceAccount
}

func (a *AmazonEKSClusterConfiguration) GetStorageClaimName() string {
	if a == nil {
		return ""
	}
	return a.StorageClaimName
}

func (a *AmazonEKSClusterConfiguration) GetStorageMountPath() *string {
	if a == nil {
		return nil
	}
	return a.StorageMountPath
}

func (a *AmazonEKSClusterConfiguration) GetPodCleanup() *PodCleanupPolicy {
	if a == nil {
		return nil
	}
	return a.PodCleanup
}

func (a *AmazonEKSClusterConfiguration) GetHeadPodSpec() *string {
	if a == nil {
		return nil
	}
	return a.HeadPodSpec
}

func (a *AmazonEKSClusterConfiguration) GetServicePodSpec() *string {
	if a == nil {
		return nil
	}
	return a.ServicePodSpec
}

func (a *AmazonEKSClusterConfiguration) GetEnvironment() []ConfigEnvVariable {
	if a == nil {
		return nil
	}
	return a.Environment
}

func (a *AmazonEKSClusterConfiguration) GetHeadJobCpus() *int {
	if a == nil {
		return nil
	}
	return a.HeadJobCpus
}

func (a *AmazonEKSClusterConfiguration) GetHeadJobMemoryMb() *int {
	if a == nil {
		return nil
	}
	return a.HeadJobMemoryMb
}

func (a *AmazonEKSClusterConfiguration) GetNextflowConfig() *string {
	if a == nil {
		return nil
	}
	return a.NextflowConfig
}

func (a *AmazonEKSClusterConfiguration) GetRegion() string {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AmazonEKSClusterConfiguration) GetClusterName() string {
	if a == nil {
		return ""
	}
	return a.ClusterName
}

func (a *AmazonEKSClusterConfiguration) GetEnableWave() *bool {
	if a == nil {
		return nil
	}
	return a.EnableWave
}

func (a *AmazonEKSClusterConfiguration) GetEnableFusion() *bool {
	if a == nil {
		return nil
	}
	return a.EnableFusion
}

type KubernetesComputeConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript         *string           `json:"postRunScript,omitempty"`
	Server                string            `json:"server"`
	SslCert               string            `json:"sslCert"`
	Namespace             string            `json:"namespace"`
	ComputeServiceAccount *string           `json:"computeServiceAccount,omitempty"`
	HeadServiceAccount    string            `json:"headServiceAccount"`
	StorageClaimName      string            `json:"storageClaimName"`
	StorageMountPath      *string           `json:"storageMountPath,omitempty"`
	PodCleanup            *PodCleanupPolicy `json:"podCleanup,omitempty"`
	HeadPodSpec           *string           `json:"headPodSpec,omitempty"`
	ServicePodSpec        *string           `json:"servicePodSpec,omitempty"`
	// Array of environment variables for the compute environment
	Environment     []ConfigEnvVariable `json:"environment,omitempty"`
	HeadJobCpus     *int                `json:"headJobCpus,omitempty"`
	HeadJobMemoryMb *int                `json:"headJobMemoryMb,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
}

func (k KubernetesComputeConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KubernetesComputeConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, []string{"server", "sslCert", "namespace", "headServiceAccount", "storageClaimName"}); err != nil {
		return err
	}
	return nil
}

func (k *KubernetesComputeConfiguration) GetDiscriminator() *string {
	if k == nil {
		return nil
	}
	return k.Discriminator
}

func (k *KubernetesComputeConfiguration) GetWorkDir() *string {
	if k == nil {
		return nil
	}
	return k.WorkDir
}

func (k *KubernetesComputeConfiguration) GetPreRunScript() *string {
	if k == nil {
		return nil
	}
	return k.PreRunScript
}

func (k *KubernetesComputeConfiguration) GetPostRunScript() *string {
	if k == nil {
		return nil
	}
	return k.PostRunScript
}

func (k *KubernetesComputeConfiguration) GetServer() string {
	if k == nil {
		return ""
	}
	return k.Server
}

func (k *KubernetesComputeConfiguration) GetSslCert() string {
	if k == nil {
		return ""
	}
	return k.SslCert
}

func (k *KubernetesComputeConfiguration) GetNamespace() string {
	if k == nil {
		return ""
	}
	return k.Namespace
}

func (k *KubernetesComputeConfiguration) GetComputeServiceAccount() *string {
	if k == nil {
		return nil
	}
	return k.ComputeServiceAccount
}

func (k *KubernetesComputeConfiguration) GetHeadServiceAccount() string {
	if k == nil {
		return ""
	}
	return k.HeadServiceAccount
}

func (k *KubernetesComputeConfiguration) GetStorageClaimName() string {
	if k == nil {
		return ""
	}
	return k.StorageClaimName
}

func (k *KubernetesComputeConfiguration) GetStorageMountPath() *string {
	if k == nil {
		return nil
	}
	return k.StorageMountPath
}

func (k *KubernetesComputeConfiguration) GetPodCleanup() *PodCleanupPolicy {
	if k == nil {
		return nil
	}
	return k.PodCleanup
}

func (k *KubernetesComputeConfiguration) GetHeadPodSpec() *string {
	if k == nil {
		return nil
	}
	return k.HeadPodSpec
}

func (k *KubernetesComputeConfiguration) GetServicePodSpec() *string {
	if k == nil {
		return nil
	}
	return k.ServicePodSpec
}

func (k *KubernetesComputeConfiguration) GetEnvironment() []ConfigEnvVariable {
	if k == nil {
		return nil
	}
	return k.Environment
}

func (k *KubernetesComputeConfiguration) GetHeadJobCpus() *int {
	if k == nil {
		return nil
	}
	return k.HeadJobCpus
}

func (k *KubernetesComputeConfiguration) GetHeadJobMemoryMb() *int {
	if k == nil {
		return nil
	}
	return k.HeadJobMemoryMb
}

func (k *KubernetesComputeConfiguration) GetNextflowConfig() *string {
	if k == nil {
		return nil
	}
	return k.NextflowConfig
}

type SlurmConfiguration struct {
	// Working directory path for workflow execution
	WorkDir string `json:"workDir"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	LaunchDir               *string `json:"launchDir,omitempty"`
	UserName                *string `json:"userName,omitempty"`
	HostName                *string `json:"hostName,omitempty"`
	Port                    *int    `json:"port,omitempty"`
	HeadQueue               *string `json:"headQueue,omitempty"`
	ComputeQueue            *string `json:"computeQueue,omitempty"`
	MaxQueueSize            *int    `json:"maxQueueSize,omitempty"`
	HeadJobOptions          *string `json:"headJobOptions,omitempty"`
	PropagateHeadJobOptions *bool   `json:"propagateHeadJobOptions,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (s SlurmConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SlurmConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"workDir"}); err != nil {
		return err
	}
	return nil
}

func (s *SlurmConfiguration) GetWorkDir() string {
	if s == nil {
		return ""
	}
	return s.WorkDir
}

func (s *SlurmConfiguration) GetPreRunScript() *string {
	if s == nil {
		return nil
	}
	return s.PreRunScript
}

func (s *SlurmConfiguration) GetPostRunScript() *string {
	if s == nil {
		return nil
	}
	return s.PostRunScript
}

func (s *SlurmConfiguration) GetNextflowConfig() *string {
	if s == nil {
		return nil
	}
	return s.NextflowConfig
}

func (s *SlurmConfiguration) GetLaunchDir() *string {
	if s == nil {
		return nil
	}
	return s.LaunchDir
}

func (s *SlurmConfiguration) GetUserName() *string {
	if s == nil {
		return nil
	}
	return s.UserName
}

func (s *SlurmConfiguration) GetHostName() *string {
	if s == nil {
		return nil
	}
	return s.HostName
}

func (s *SlurmConfiguration) GetPort() *int {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SlurmConfiguration) GetHeadQueue() *string {
	if s == nil {
		return nil
	}
	return s.HeadQueue
}

func (s *SlurmConfiguration) GetComputeQueue() *string {
	if s == nil {
		return nil
	}
	return s.ComputeQueue
}

func (s *SlurmConfiguration) GetMaxQueueSize() *int {
	if s == nil {
		return nil
	}
	return s.MaxQueueSize
}

func (s *SlurmConfiguration) GetHeadJobOptions() *string {
	if s == nil {
		return nil
	}
	return s.HeadJobOptions
}

func (s *SlurmConfiguration) GetPropagateHeadJobOptions() *bool {
	if s == nil {
		return nil
	}
	return s.PropagateHeadJobOptions
}

func (s *SlurmConfiguration) GetDiscriminator() *string {
	if s == nil {
		return nil
	}
	return s.Discriminator
}

func (s *SlurmConfiguration) GetEnvironment() []ConfigEnvVariable {
	if s == nil {
		return nil
	}
	return s.Environment
}

type IBMLSFConfiguration struct {
	// Working directory path for workflow execution
	WorkDir string `json:"workDir"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	LaunchDir               *string `json:"launchDir,omitempty"`
	UserName                *string `json:"userName,omitempty"`
	HostName                *string `json:"hostName,omitempty"`
	Port                    *int    `json:"port,omitempty"`
	HeadQueue               *string `json:"headQueue,omitempty"`
	ComputeQueue            *string `json:"computeQueue,omitempty"`
	MaxQueueSize            *int    `json:"maxQueueSize,omitempty"`
	HeadJobOptions          *string `json:"headJobOptions,omitempty"`
	PropagateHeadJobOptions *bool   `json:"propagateHeadJobOptions,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator  *string `json:"discriminator,omitempty"`
	UnitForLimits  *string `json:"unitForLimits,omitempty"`
	PerJobMemLimit *bool   `json:"perJobMemLimit,omitempty"`
	PerTaskReserve *bool   `json:"perTaskReserve,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (i IBMLSFConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IBMLSFConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"workDir"}); err != nil {
		return err
	}
	return nil
}

func (i *IBMLSFConfiguration) GetWorkDir() string {
	if i == nil {
		return ""
	}
	return i.WorkDir
}

func (i *IBMLSFConfiguration) GetPreRunScript() *string {
	if i == nil {
		return nil
	}
	return i.PreRunScript
}

func (i *IBMLSFConfiguration) GetPostRunScript() *string {
	if i == nil {
		return nil
	}
	return i.PostRunScript
}

func (i *IBMLSFConfiguration) GetNextflowConfig() *string {
	if i == nil {
		return nil
	}
	return i.NextflowConfig
}

func (i *IBMLSFConfiguration) GetLaunchDir() *string {
	if i == nil {
		return nil
	}
	return i.LaunchDir
}

func (i *IBMLSFConfiguration) GetUserName() *string {
	if i == nil {
		return nil
	}
	return i.UserName
}

func (i *IBMLSFConfiguration) GetHostName() *string {
	if i == nil {
		return nil
	}
	return i.HostName
}

func (i *IBMLSFConfiguration) GetPort() *int {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *IBMLSFConfiguration) GetHeadQueue() *string {
	if i == nil {
		return nil
	}
	return i.HeadQueue
}

func (i *IBMLSFConfiguration) GetComputeQueue() *string {
	if i == nil {
		return nil
	}
	return i.ComputeQueue
}

func (i *IBMLSFConfiguration) GetMaxQueueSize() *int {
	if i == nil {
		return nil
	}
	return i.MaxQueueSize
}

func (i *IBMLSFConfiguration) GetHeadJobOptions() *string {
	if i == nil {
		return nil
	}
	return i.HeadJobOptions
}

func (i *IBMLSFConfiguration) GetPropagateHeadJobOptions() *bool {
	if i == nil {
		return nil
	}
	return i.PropagateHeadJobOptions
}

func (i *IBMLSFConfiguration) GetDiscriminator() *string {
	if i == nil {
		return nil
	}
	return i.Discriminator
}

func (i *IBMLSFConfiguration) GetUnitForLimits() *string {
	if i == nil {
		return nil
	}
	return i.UnitForLimits
}

func (i *IBMLSFConfiguration) GetPerJobMemLimit() *bool {
	if i == nil {
		return nil
	}
	return i.PerJobMemLimit
}

func (i *IBMLSFConfiguration) GetPerTaskReserve() *bool {
	if i == nil {
		return nil
	}
	return i.PerTaskReserve
}

func (i *IBMLSFConfiguration) GetEnvironment() []ConfigEnvVariable {
	if i == nil {
		return nil
	}
	return i.Environment
}

type AzureBatchConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	Region        string  `json:"region"`
	HeadPool      *string `json:"headPool,omitempty"`
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	AutoPoolMode            *bool               `json:"autoPoolMode,omitempty"`
	Forge                   *AzBatchForgeConfig `json:"forge,omitempty"`
	TokenDuration           *string             `json:"tokenDuration,omitempty"`
	DeleteJobsOnCompletion  *JobCleanupPolicy   `json:"deleteJobsOnCompletion,omitempty"`
	DeletePoolsOnCompletion *bool               `json:"deletePoolsOnCompletion,omitempty"`
	// Array of environment variables for the compute environment
	Environment  []ConfigEnvVariable `json:"environment,omitempty"`
	EnableWave   *bool               `json:"waveEnabled,omitempty"`
	EnableFusion *bool               `json:"fusion2Enabled,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig          *string `json:"nextflowConfig,omitempty"`
	ManagedIdentityClientID *string `json:"managedIdentityClientId,omitempty"`
}

func (a AzureBatchConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBatchConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"region"}); err != nil {
		return err
	}
	return nil
}

func (a *AzureBatchConfiguration) GetDiscriminator() *string {
	if a == nil {
		return nil
	}
	return a.Discriminator
}

func (a *AzureBatchConfiguration) GetWorkDir() *string {
	if a == nil {
		return nil
	}
	return a.WorkDir
}

func (a *AzureBatchConfiguration) GetPreRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PreRunScript
}

func (a *AzureBatchConfiguration) GetPostRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PostRunScript
}

func (a *AzureBatchConfiguration) GetRegion() string {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AzureBatchConfiguration) GetHeadPool() *string {
	if a == nil {
		return nil
	}
	return a.HeadPool
}

func (a *AzureBatchConfiguration) GetAutoPoolMode() *bool {
	if a == nil {
		return nil
	}
	return a.AutoPoolMode
}

func (a *AzureBatchConfiguration) GetForge() *AzBatchForgeConfig {
	if a == nil {
		return nil
	}
	return a.Forge
}

func (a *AzureBatchConfiguration) GetTokenDuration() *string {
	if a == nil {
		return nil
	}
	return a.TokenDuration
}

func (a *AzureBatchConfiguration) GetDeleteJobsOnCompletion() *JobCleanupPolicy {
	if a == nil {
		return nil
	}
	return a.DeleteJobsOnCompletion
}

func (a *AzureBatchConfiguration) GetDeletePoolsOnCompletion() *bool {
	if a == nil {
		return nil
	}
	return a.DeletePoolsOnCompletion
}

func (a *AzureBatchConfiguration) GetEnvironment() []ConfigEnvVariable {
	if a == nil {
		return nil
	}
	return a.Environment
}

func (a *AzureBatchConfiguration) GetEnableWave() *bool {
	if a == nil {
		return nil
	}
	return a.EnableWave
}

func (a *AzureBatchConfiguration) GetEnableFusion() *bool {
	if a == nil {
		return nil
	}
	return a.EnableFusion
}

func (a *AzureBatchConfiguration) GetNextflowConfig() *string {
	if a == nil {
		return nil
	}
	return a.NextflowConfig
}

func (a *AzureBatchConfiguration) GetManagedIdentityClientID() *string {
	if a == nil {
		return nil
	}
	return a.ManagedIdentityClientID
}

type GoogleBatchServiceConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	Location      *string `json:"location,omitempty"`
	// Working directory path for workflow execution
	WorkDir           *string           `json:"workDir,omitempty"`
	Spot              *bool             `json:"spot,omitempty"`
	BootDiskSizeGb    *int              `json:"bootDiskSizeGb,omitempty"`
	CPUPlatform       *string           `json:"cpuPlatform,omitempty"`
	MachineType       *string           `json:"machineType,omitempty"`
	ProjectID         *string           `json:"projectId,omitempty"`
	SSHDaemon         *bool             `json:"sshDaemon,omitempty"`
	SSHImage          *string           `json:"sshImage,omitempty"`
	DebugMode         *int              `json:"debugMode,omitempty"`
	CopyImage         *string           `json:"copyImage,omitempty"`
	UsePrivateAddress *bool             `json:"usePrivateAddress,omitempty"`
	Labels            map[string]string `json:"labels,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript   *string `json:"postRunScript,omitempty"`
	HeadJobCpus     *int    `json:"headJobCpus,omitempty"`
	HeadJobMemoryMb *int    `json:"headJobMemoryMb,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
	NfsTarget      *string `json:"nfsTarget,omitempty"`
	NfsMount       *string `json:"nfsMount,omitempty"`
	// Array of environment variables for the compute environment
	Environment                 []ConfigEnvVariable `json:"environment,omitempty"`
	EnableWave                  *bool               `json:"waveEnabled,omitempty"`
	EnableFusion                *bool               `json:"fusion2Enabled,omitempty"`
	ServiceAccount              *string             `json:"serviceAccount,omitempty"`
	Network                     *string             `json:"network,omitempty"`
	Subnetwork                  *string             `json:"subnetwork,omitempty"`
	HeadJobInstanceTemplate     *string             `json:"headJobInstanceTemplate,omitempty"`
	ComputeJobsInstanceTemplate *string             `json:"computeJobsInstanceTemplate,omitempty"`
}

func (g GoogleBatchServiceConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GoogleBatchServiceConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GoogleBatchServiceConfiguration) GetDiscriminator() *string {
	if g == nil {
		return nil
	}
	return g.Discriminator
}

func (g *GoogleBatchServiceConfiguration) GetLocation() *string {
	if g == nil {
		return nil
	}
	return g.Location
}

func (g *GoogleBatchServiceConfiguration) GetWorkDir() *string {
	if g == nil {
		return nil
	}
	return g.WorkDir
}

func (g *GoogleBatchServiceConfiguration) GetSpot() *bool {
	if g == nil {
		return nil
	}
	return g.Spot
}

func (g *GoogleBatchServiceConfiguration) GetBootDiskSizeGb() *int {
	if g == nil {
		return nil
	}
	return g.BootDiskSizeGb
}

func (g *GoogleBatchServiceConfiguration) GetCPUPlatform() *string {
	if g == nil {
		return nil
	}
	return g.CPUPlatform
}

func (g *GoogleBatchServiceConfiguration) GetMachineType() *string {
	if g == nil {
		return nil
	}
	return g.MachineType
}

func (g *GoogleBatchServiceConfiguration) GetProjectID() *string {
	if g == nil {
		return nil
	}
	return g.ProjectID
}

func (g *GoogleBatchServiceConfiguration) GetSSHDaemon() *bool {
	if g == nil {
		return nil
	}
	return g.SSHDaemon
}

func (g *GoogleBatchServiceConfiguration) GetSSHImage() *string {
	if g == nil {
		return nil
	}
	return g.SSHImage
}

func (g *GoogleBatchServiceConfiguration) GetDebugMode() *int {
	if g == nil {
		return nil
	}
	return g.DebugMode
}

func (g *GoogleBatchServiceConfiguration) GetCopyImage() *string {
	if g == nil {
		return nil
	}
	return g.CopyImage
}

func (g *GoogleBatchServiceConfiguration) GetUsePrivateAddress() *bool {
	if g == nil {
		return nil
	}
	return g.UsePrivateAddress
}

func (g *GoogleBatchServiceConfiguration) GetLabels() map[string]string {
	if g == nil {
		return nil
	}
	return g.Labels
}

func (g *GoogleBatchServiceConfiguration) GetPreRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PreRunScript
}

func (g *GoogleBatchServiceConfiguration) GetPostRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PostRunScript
}

func (g *GoogleBatchServiceConfiguration) GetHeadJobCpus() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobCpus
}

func (g *GoogleBatchServiceConfiguration) GetHeadJobMemoryMb() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobMemoryMb
}

func (g *GoogleBatchServiceConfiguration) GetNextflowConfig() *string {
	if g == nil {
		return nil
	}
	return g.NextflowConfig
}

func (g *GoogleBatchServiceConfiguration) GetNfsTarget() *string {
	if g == nil {
		return nil
	}
	return g.NfsTarget
}

func (g *GoogleBatchServiceConfiguration) GetNfsMount() *string {
	if g == nil {
		return nil
	}
	return g.NfsMount
}

func (g *GoogleBatchServiceConfiguration) GetEnvironment() []ConfigEnvVariable {
	if g == nil {
		return nil
	}
	return g.Environment
}

func (g *GoogleBatchServiceConfiguration) GetEnableWave() *bool {
	if g == nil {
		return nil
	}
	return g.EnableWave
}

func (g *GoogleBatchServiceConfiguration) GetEnableFusion() *bool {
	if g == nil {
		return nil
	}
	return g.EnableFusion
}

func (g *GoogleBatchServiceConfiguration) GetServiceAccount() *string {
	if g == nil {
		return nil
	}
	return g.ServiceAccount
}

func (g *GoogleBatchServiceConfiguration) GetNetwork() *string {
	if g == nil {
		return nil
	}
	return g.Network
}

func (g *GoogleBatchServiceConfiguration) GetSubnetwork() *string {
	if g == nil {
		return nil
	}
	return g.Subnetwork
}

func (g *GoogleBatchServiceConfiguration) GetHeadJobInstanceTemplate() *string {
	if g == nil {
		return nil
	}
	return g.HeadJobInstanceTemplate
}

func (g *GoogleBatchServiceConfiguration) GetComputeJobsInstanceTemplate() *string {
	if g == nil {
		return nil
	}
	return g.ComputeJobsInstanceTemplate
}

type GoogleLifeSciencesConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string  `json:"discriminator,omitempty"`
	Region        *string  `json:"region,omitempty"`
	Zones         []string `json:"zones,omitempty"`
	Location      *string  `json:"location,omitempty"`
	// Working directory path for workflow execution
	WorkDir           *string           `json:"workDir,omitempty"`
	Preemptible       *bool             `json:"preemptible,omitempty"`
	BootDiskSizeGb    *int              `json:"bootDiskSizeGb,omitempty"`
	ProjectID         *string           `json:"projectId,omitempty"`
	SSHDaemon         *bool             `json:"sshDaemon,omitempty"`
	SSHImage          *string           `json:"sshImage,omitempty"`
	DebugMode         *int              `json:"debugMode,omitempty"`
	CopyImage         *string           `json:"copyImage,omitempty"`
	UsePrivateAddress *bool             `json:"usePrivateAddress,omitempty"`
	Labels            map[string]string `json:"labels,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript   *string `json:"postRunScript,omitempty"`
	HeadJobCpus     *int    `json:"headJobCpus,omitempty"`
	HeadJobMemoryMb *int    `json:"headJobMemoryMb,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
	NfsTarget      *string `json:"nfsTarget,omitempty"`
	NfsMount       *string `json:"nfsMount,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
}

func (g GoogleLifeSciencesConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GoogleLifeSciencesConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GoogleLifeSciencesConfiguration) GetDiscriminator() *string {
	if g == nil {
		return nil
	}
	return g.Discriminator
}

func (g *GoogleLifeSciencesConfiguration) GetRegion() *string {
	if g == nil {
		return nil
	}
	return g.Region
}

func (g *GoogleLifeSciencesConfiguration) GetZones() []string {
	if g == nil {
		return nil
	}
	return g.Zones
}

func (g *GoogleLifeSciencesConfiguration) GetLocation() *string {
	if g == nil {
		return nil
	}
	return g.Location
}

func (g *GoogleLifeSciencesConfiguration) GetWorkDir() *string {
	if g == nil {
		return nil
	}
	return g.WorkDir
}

func (g *GoogleLifeSciencesConfiguration) GetPreemptible() *bool {
	if g == nil {
		return nil
	}
	return g.Preemptible
}

func (g *GoogleLifeSciencesConfiguration) GetBootDiskSizeGb() *int {
	if g == nil {
		return nil
	}
	return g.BootDiskSizeGb
}

func (g *GoogleLifeSciencesConfiguration) GetProjectID() *string {
	if g == nil {
		return nil
	}
	return g.ProjectID
}

func (g *GoogleLifeSciencesConfiguration) GetSSHDaemon() *bool {
	if g == nil {
		return nil
	}
	return g.SSHDaemon
}

func (g *GoogleLifeSciencesConfiguration) GetSSHImage() *string {
	if g == nil {
		return nil
	}
	return g.SSHImage
}

func (g *GoogleLifeSciencesConfiguration) GetDebugMode() *int {
	if g == nil {
		return nil
	}
	return g.DebugMode
}

func (g *GoogleLifeSciencesConfiguration) GetCopyImage() *string {
	if g == nil {
		return nil
	}
	return g.CopyImage
}

func (g *GoogleLifeSciencesConfiguration) GetUsePrivateAddress() *bool {
	if g == nil {
		return nil
	}
	return g.UsePrivateAddress
}

func (g *GoogleLifeSciencesConfiguration) GetLabels() map[string]string {
	if g == nil {
		return nil
	}
	return g.Labels
}

func (g *GoogleLifeSciencesConfiguration) GetPreRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PreRunScript
}

func (g *GoogleLifeSciencesConfiguration) GetPostRunScript() *string {
	if g == nil {
		return nil
	}
	return g.PostRunScript
}

func (g *GoogleLifeSciencesConfiguration) GetHeadJobCpus() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobCpus
}

func (g *GoogleLifeSciencesConfiguration) GetHeadJobMemoryMb() *int {
	if g == nil {
		return nil
	}
	return g.HeadJobMemoryMb
}

func (g *GoogleLifeSciencesConfiguration) GetNextflowConfig() *string {
	if g == nil {
		return nil
	}
	return g.NextflowConfig
}

func (g *GoogleLifeSciencesConfiguration) GetNfsTarget() *string {
	if g == nil {
		return nil
	}
	return g.NfsTarget
}

func (g *GoogleLifeSciencesConfiguration) GetNfsMount() *string {
	if g == nil {
		return nil
	}
	return g.NfsMount
}

func (g *GoogleLifeSciencesConfiguration) GetEnvironment() []ConfigEnvVariable {
	if g == nil {
		return nil
	}
	return g.Environment
}

type SeqeraComputeConfiguration struct {
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	StorageType *string `json:"storageType,omitempty"`
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	LustreID *string  `json:"lustreId,omitempty"`
	Volumes  []string `json:"volumes,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// AWS region where the Batch compute environment will be created.
	// Examples: us-east-1, eu-west-1, ap-southeast-2
	//
	Region string `json:"region"`
	// Name of the AWS Batch compute queue
	ComputeQueue       *string `json:"computeQueue,omitempty"`
	DragenQueue        *string `json:"dragenQueue,omitempty"`
	DragenInstanceType *string `json:"dragenInstanceType,omitempty"`
	// IAM role ARN for compute jobs. Jobs assume this role during execution.
	// Must have permissions for S3, CloudWatch, etc.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ComputeJobRole *string `json:"computeJobRole,omitempty"`
	// IAM role ARN for Batch execution (pulling container images, writing logs).
	// Must have permissions for ECR and CloudWatch Logs.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ExecutionRole *string `json:"executionRole,omitempty"`
	// Name of the head job queue
	HeadQueue *string `json:"headQueue,omitempty"`
	// IAM role ARN for the head job.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	HeadJobRole *string `json:"headJobRole,omitempty"`
	// Path to AWS CLI on compute instances. AWS CLI must be available at this path.
	//
	CliPath *string `json:"cliPath,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Number of CPUs allocated for the head job (default: 1)
	HeadJobCpus *int `json:"headJobCpus,omitempty"`
	// Memory allocation for the head job in MB (default: 1024)
	HeadJobMemoryMb *int `json:"headJobMemoryMb,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
	// Enable Wave containers for this compute environment. Wave provides container provisioning
	// and augmentation capabilities for Nextflow workflows.
	//
	// When enable_wave is true, enable_fusion must be explicitly set to either true or false.
	// Note: If Fusion2 is enabled, Wave must also be enabled.
	//
	EnableWave   *bool `json:"waveEnabled,omitempty"`
	EnableFusion *bool `json:"fusion2Enabled,omitempty"`
	// Enable NVMe instance storage for high-performance I/O.
	// When enabled, NVMe storage volumes are automatically mounted and configured.
	//
	NvmeStorageEnabled *bool   `json:"nvnmeStorageEnabled,omitempty"`
	LogGroup           *string `json:"logGroup,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig  *string          `json:"nextflowConfig,omitempty"`
	FusionSnapshots *bool            `json:"fusionSnapshots,omitempty"`
	Forge           *ForgeConfig     `json:"forge,omitempty"`
	ForgedResources []map[string]any `json:"forgedResources,omitempty"`
}

func (s SeqeraComputeConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SeqeraComputeConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"region"}); err != nil {
		return err
	}
	return nil
}

func (s *SeqeraComputeConfiguration) GetStorageType() *string {
	if s == nil {
		return nil
	}
	return s.StorageType
}

func (s *SeqeraComputeConfiguration) GetLustreID() *string {
	if s == nil {
		return nil
	}
	return s.LustreID
}

func (s *SeqeraComputeConfiguration) GetVolumes() []string {
	if s == nil {
		return nil
	}
	return s.Volumes
}

func (s *SeqeraComputeConfiguration) GetDiscriminator() *string {
	if s == nil {
		return nil
	}
	return s.Discriminator
}

func (s *SeqeraComputeConfiguration) GetRegion() string {
	if s == nil {
		return ""
	}
	return s.Region
}

func (s *SeqeraComputeConfiguration) GetComputeQueue() *string {
	if s == nil {
		return nil
	}
	return s.ComputeQueue
}

func (s *SeqeraComputeConfiguration) GetDragenQueue() *string {
	if s == nil {
		return nil
	}
	return s.DragenQueue
}

func (s *SeqeraComputeConfiguration) GetDragenInstanceType() *string {
	if s == nil {
		return nil
	}
	return s.DragenInstanceType
}

func (s *SeqeraComputeConfiguration) GetComputeJobRole() *string {
	if s == nil {
		return nil
	}
	return s.ComputeJobRole
}

func (s *SeqeraComputeConfiguration) GetExecutionRole() *string {
	if s == nil {
		return nil
	}
	return s.ExecutionRole
}

func (s *SeqeraComputeConfiguration) GetHeadQueue() *string {
	if s == nil {
		return nil
	}
	return s.HeadQueue
}

func (s *SeqeraComputeConfiguration) GetHeadJobRole() *string {
	if s == nil {
		return nil
	}
	return s.HeadJobRole
}

func (s *SeqeraComputeConfiguration) GetCliPath() *string {
	if s == nil {
		return nil
	}
	return s.CliPath
}

func (s *SeqeraComputeConfiguration) GetWorkDir() *string {
	if s == nil {
		return nil
	}
	return s.WorkDir
}

func (s *SeqeraComputeConfiguration) GetPreRunScript() *string {
	if s == nil {
		return nil
	}
	return s.PreRunScript
}

func (s *SeqeraComputeConfiguration) GetPostRunScript() *string {
	if s == nil {
		return nil
	}
	return s.PostRunScript
}

func (s *SeqeraComputeConfiguration) GetHeadJobCpus() *int {
	if s == nil {
		return nil
	}
	return s.HeadJobCpus
}

func (s *SeqeraComputeConfiguration) GetHeadJobMemoryMb() *int {
	if s == nil {
		return nil
	}
	return s.HeadJobMemoryMb
}

func (s *SeqeraComputeConfiguration) GetEnvironment() []ConfigEnvVariable {
	if s == nil {
		return nil
	}
	return s.Environment
}

func (s *SeqeraComputeConfiguration) GetEnableWave() *bool {
	if s == nil {
		return nil
	}
	return s.EnableWave
}

func (s *SeqeraComputeConfiguration) GetEnableFusion() *bool {
	if s == nil {
		return nil
	}
	return s.EnableFusion
}

func (s *SeqeraComputeConfiguration) GetNvmeStorageEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.NvmeStorageEnabled
}

func (s *SeqeraComputeConfiguration) GetLogGroup() *string {
	if s == nil {
		return nil
	}
	return s.LogGroup
}

func (s *SeqeraComputeConfiguration) GetNextflowConfig() *string {
	if s == nil {
		return nil
	}
	return s.NextflowConfig
}

func (s *SeqeraComputeConfiguration) GetFusionSnapshots() *bool {
	if s == nil {
		return nil
	}
	return s.FusionSnapshots
}

func (s *SeqeraComputeConfiguration) GetForge() *ForgeConfig {
	if s == nil {
		return nil
	}
	return s.Forge
}

func (s *SeqeraComputeConfiguration) GetForgedResources() []map[string]any {
	if s == nil {
		return nil
	}
	return s.ForgedResources
}

type AWSCloudConfiguration struct {
	// Read-only property identifying the compute platform type
	Discriminator *string  `json:"discriminator,omitempty"`
	AllowBuckets  []string `json:"allowBuckets,omitempty"`
	Region        string   `json:"region"`
	InstanceType  *string  `json:"instanceType,omitempty"`
	ImageID       *string  `json:"imageId,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig *string `json:"nextflowConfig,omitempty"`
	// Array of environment variables for the compute environment
	Environment        []ConfigEnvVariable `json:"environment,omitempty"`
	EnableWave         *bool               `json:"waveEnabled,omitempty"`
	EnableFusion       *bool               `json:"fusion2Enabled,omitempty"`
	LogGroup           *string             `json:"logGroup,omitempty"`
	Arm64Enabled       *bool               `json:"arm64Enabled,omitempty"`
	GpuEnabled         *bool               `json:"gpuEnabled,omitempty"`
	Ec2KeyPair         *string             `json:"ec2KeyPair,omitempty"`
	EbsBootSize        *int                `json:"ebsBootSize,omitempty"`
	InstanceProfileArn *string             `json:"instanceProfileArn,omitempty"`
	SubnetID           *string             `json:"subnetId,omitempty"`
	SecurityGroups     []string            `json:"securityGroups,omitempty"`
	ForgedResources    []map[string]any    `json:"forgedResources,omitempty"`
}

func (a AWSCloudConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSCloudConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"region"}); err != nil {
		return err
	}
	return nil
}

func (a *AWSCloudConfiguration) GetDiscriminator() *string {
	if a == nil {
		return nil
	}
	return a.Discriminator
}

func (a *AWSCloudConfiguration) GetAllowBuckets() []string {
	if a == nil {
		return nil
	}
	return a.AllowBuckets
}

func (a *AWSCloudConfiguration) GetRegion() string {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AWSCloudConfiguration) GetInstanceType() *string {
	if a == nil {
		return nil
	}
	return a.InstanceType
}

func (a *AWSCloudConfiguration) GetImageID() *string {
	if a == nil {
		return nil
	}
	return a.ImageID
}

func (a *AWSCloudConfiguration) GetWorkDir() *string {
	if a == nil {
		return nil
	}
	return a.WorkDir
}

func (a *AWSCloudConfiguration) GetPreRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PreRunScript
}

func (a *AWSCloudConfiguration) GetPostRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PostRunScript
}

func (a *AWSCloudConfiguration) GetNextflowConfig() *string {
	if a == nil {
		return nil
	}
	return a.NextflowConfig
}

func (a *AWSCloudConfiguration) GetEnvironment() []ConfigEnvVariable {
	if a == nil {
		return nil
	}
	return a.Environment
}

func (a *AWSCloudConfiguration) GetEnableWave() *bool {
	if a == nil {
		return nil
	}
	return a.EnableWave
}

func (a *AWSCloudConfiguration) GetEnableFusion() *bool {
	if a == nil {
		return nil
	}
	return a.EnableFusion
}

func (a *AWSCloudConfiguration) GetLogGroup() *string {
	if a == nil {
		return nil
	}
	return a.LogGroup
}

func (a *AWSCloudConfiguration) GetArm64Enabled() *bool {
	if a == nil {
		return nil
	}
	return a.Arm64Enabled
}

func (a *AWSCloudConfiguration) GetGpuEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.GpuEnabled
}

func (a *AWSCloudConfiguration) GetEc2KeyPair() *string {
	if a == nil {
		return nil
	}
	return a.Ec2KeyPair
}

func (a *AWSCloudConfiguration) GetEbsBootSize() *int {
	if a == nil {
		return nil
	}
	return a.EbsBootSize
}

func (a *AWSCloudConfiguration) GetInstanceProfileArn() *string {
	if a == nil {
		return nil
	}
	return a.InstanceProfileArn
}

func (a *AWSCloudConfiguration) GetSubnetID() *string {
	if a == nil {
		return nil
	}
	return a.SubnetID
}

func (a *AWSCloudConfiguration) GetSecurityGroups() []string {
	if a == nil {
		return nil
	}
	return a.SecurityGroups
}

func (a *AWSCloudConfiguration) GetForgedResources() []map[string]any {
	if a == nil {
		return nil
	}
	return a.ForgedResources
}

type AWSBatchConfiguration struct {
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	StorageType *string `json:"storageType,omitempty"`
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	LustreID *string  `json:"lustreId,omitempty"`
	Volumes  []string `json:"volumes,omitempty"`
	// Read-only property identifying the compute platform type
	Discriminator *string `json:"discriminator,omitempty"`
	// AWS region where the Batch compute environment will be created.
	// Examples: us-east-1, eu-west-1, ap-southeast-2
	//
	Region string `json:"region"`
	// Name of the AWS Batch compute queue
	ComputeQueue       *string `json:"computeQueue,omitempty"`
	DragenQueue        *string `json:"dragenQueue,omitempty"`
	DragenInstanceType *string `json:"dragenInstanceType,omitempty"`
	// IAM role ARN for compute jobs. Jobs assume this role during execution.
	// Must have permissions for S3, CloudWatch, etc.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ComputeJobRole *string `json:"computeJobRole,omitempty"`
	// IAM role ARN for Batch execution (pulling container images, writing logs).
	// Must have permissions for ECR and CloudWatch Logs.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	ExecutionRole *string `json:"executionRole,omitempty"`
	// Name of the head job queue
	HeadQueue *string `json:"headQueue,omitempty"`
	// IAM role ARN for the head job.
	// Format: arn:aws:iam::account-id:role/role-name
	//
	HeadJobRole *string `json:"headJobRole,omitempty"`
	// Path to AWS CLI on compute instances. AWS CLI must be available at this path.
	//
	CliPath *string `json:"cliPath,omitempty"`
	// Working directory path for workflow execution
	WorkDir *string `json:"workDir,omitempty"`
	// Shell script to execute before workflow starts
	PreRunScript *string `json:"preRunScript,omitempty"`
	// Shell script to execute after workflow completes
	PostRunScript *string `json:"postRunScript,omitempty"`
	// Number of CPUs allocated for the head job (default: 1)
	HeadJobCpus *int `json:"headJobCpus,omitempty"`
	// Memory allocation for the head job in MB (default: 1024)
	HeadJobMemoryMb *int `json:"headJobMemoryMb,omitempty"`
	// Array of environment variables for the compute environment
	Environment []ConfigEnvVariable `json:"environment,omitempty"`
	// Enable Wave containers for this compute environment. Wave provides container provisioning
	// and augmentation capabilities for Nextflow workflows.
	//
	// When enable_wave is true, enable_fusion must be explicitly set to either true or false.
	// Note: If Fusion2 is enabled, Wave must also be enabled.
	//
	EnableWave   *bool `json:"waveEnabled,omitempty"`
	EnableFusion *bool `json:"fusion2Enabled,omitempty"`
	// Enable NVMe instance storage for high-performance I/O.
	// When enabled, NVMe storage volumes are automatically mounted and configured.
	//
	NvmeStorageEnabled *bool   `json:"nvnmeStorageEnabled,omitempty"`
	LogGroup           *string `json:"logGroup,omitempty"`
	// Nextflow configuration settings and parameters
	NextflowConfig  *string          `json:"nextflowConfig,omitempty"`
	FusionSnapshots *bool            `json:"fusionSnapshots,omitempty"`
	Forge           *ForgeConfig     `json:"forge,omitempty"`
	ForgedResources []map[string]any `json:"forgedResources,omitempty"`
}

func (a AWSBatchConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSBatchConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"region"}); err != nil {
		return err
	}
	return nil
}

func (a *AWSBatchConfiguration) GetStorageType() *string {
	if a == nil {
		return nil
	}
	return a.StorageType
}

func (a *AWSBatchConfiguration) GetLustreID() *string {
	if a == nil {
		return nil
	}
	return a.LustreID
}

func (a *AWSBatchConfiguration) GetVolumes() []string {
	if a == nil {
		return nil
	}
	return a.Volumes
}

func (a *AWSBatchConfiguration) GetDiscriminator() *string {
	if a == nil {
		return nil
	}
	return a.Discriminator
}

func (a *AWSBatchConfiguration) GetRegion() string {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AWSBatchConfiguration) GetComputeQueue() *string {
	if a == nil {
		return nil
	}
	return a.ComputeQueue
}

func (a *AWSBatchConfiguration) GetDragenQueue() *string {
	if a == nil {
		return nil
	}
	return a.DragenQueue
}

func (a *AWSBatchConfiguration) GetDragenInstanceType() *string {
	if a == nil {
		return nil
	}
	return a.DragenInstanceType
}

func (a *AWSBatchConfiguration) GetComputeJobRole() *string {
	if a == nil {
		return nil
	}
	return a.ComputeJobRole
}

func (a *AWSBatchConfiguration) GetExecutionRole() *string {
	if a == nil {
		return nil
	}
	return a.ExecutionRole
}

func (a *AWSBatchConfiguration) GetHeadQueue() *string {
	if a == nil {
		return nil
	}
	return a.HeadQueue
}

func (a *AWSBatchConfiguration) GetHeadJobRole() *string {
	if a == nil {
		return nil
	}
	return a.HeadJobRole
}

func (a *AWSBatchConfiguration) GetCliPath() *string {
	if a == nil {
		return nil
	}
	return a.CliPath
}

func (a *AWSBatchConfiguration) GetWorkDir() *string {
	if a == nil {
		return nil
	}
	return a.WorkDir
}

func (a *AWSBatchConfiguration) GetPreRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PreRunScript
}

func (a *AWSBatchConfiguration) GetPostRunScript() *string {
	if a == nil {
		return nil
	}
	return a.PostRunScript
}

func (a *AWSBatchConfiguration) GetHeadJobCpus() *int {
	if a == nil {
		return nil
	}
	return a.HeadJobCpus
}

func (a *AWSBatchConfiguration) GetHeadJobMemoryMb() *int {
	if a == nil {
		return nil
	}
	return a.HeadJobMemoryMb
}

func (a *AWSBatchConfiguration) GetEnvironment() []ConfigEnvVariable {
	if a == nil {
		return nil
	}
	return a.Environment
}

func (a *AWSBatchConfiguration) GetEnableWave() *bool {
	if a == nil {
		return nil
	}
	return a.EnableWave
}

func (a *AWSBatchConfiguration) GetEnableFusion() *bool {
	if a == nil {
		return nil
	}
	return a.EnableFusion
}

func (a *AWSBatchConfiguration) GetNvmeStorageEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.NvmeStorageEnabled
}

func (a *AWSBatchConfiguration) GetLogGroup() *string {
	if a == nil {
		return nil
	}
	return a.LogGroup
}

func (a *AWSBatchConfiguration) GetNextflowConfig() *string {
	if a == nil {
		return nil
	}
	return a.NextflowConfig
}

func (a *AWSBatchConfiguration) GetFusionSnapshots() *bool {
	if a == nil {
		return nil
	}
	return a.FusionSnapshots
}

func (a *AWSBatchConfiguration) GetForge() *ForgeConfig {
	if a == nil {
		return nil
	}
	return a.Forge
}

func (a *AWSBatchConfiguration) GetForgedResources() []map[string]any {
	if a == nil {
		return nil
	}
	return a.ForgedResources
}

type ComputeConfigType string

const (
	ComputeConfigTypeMoabPlatform          ComputeConfigType = "moab-platform"
	ComputeConfigTypeAwsBatch              ComputeConfigType = "aws-batch"
	ComputeConfigTypeGkePlatform           ComputeConfigType = "gke-platform"
	ComputeConfigTypeGoogleBatch           ComputeConfigType = "google-batch"
	ComputeConfigTypeAwsCloud              ComputeConfigType = "aws-cloud"
	ComputeConfigTypeSlurmPlatform         ComputeConfigType = "slurm-platform"
	ComputeConfigTypeK8sPlatform           ComputeConfigType = "k8s-platform"
	ComputeConfigTypeAltairPlatform        ComputeConfigType = "altair-platform"
	ComputeConfigTypeLsfPlatform           ComputeConfigType = "lsf-platform"
	ComputeConfigTypeAzureBatch            ComputeConfigType = "azure-batch"
	ComputeConfigTypeSeqeracomputePlatform ComputeConfigType = "seqeracompute-platform"
	ComputeConfigTypeEksPlatform           ComputeConfigType = "eks-platform"
	ComputeConfigTypeGoogleLifesciences    ComputeConfigType = "google-lifesciences"
	ComputeConfigTypeUgePlatform           ComputeConfigType = "uge-platform"
)

// ComputeConfig - Configuration settings for compute environments including work directories,
// pre/post run scripts, and environment-specific parameters.
type ComputeConfig struct {
	AWSBatchConfiguration           *AWSBatchConfiguration           `queryParam:"inline,name=ComputeConfig"`
	AWSCloudConfiguration           *AWSCloudConfiguration           `queryParam:"inline,name=ComputeConfig"`
	SeqeraComputeConfiguration      *SeqeraComputeConfiguration      `queryParam:"inline,name=ComputeConfig"`
	GoogleLifeSciencesConfiguration *GoogleLifeSciencesConfiguration `queryParam:"inline,name=ComputeConfig"`
	GoogleBatchServiceConfiguration *GoogleBatchServiceConfiguration `queryParam:"inline,name=ComputeConfig"`
	AzureBatchConfiguration         *AzureBatchConfiguration         `queryParam:"inline,name=ComputeConfig"`
	IBMLSFConfiguration             *IBMLSFConfiguration             `queryParam:"inline,name=ComputeConfig"`
	SlurmConfiguration              *SlurmConfiguration              `queryParam:"inline,name=ComputeConfig"`
	KubernetesComputeConfiguration  *KubernetesComputeConfiguration  `queryParam:"inline,name=ComputeConfig"`
	AmazonEKSClusterConfiguration   *AmazonEKSClusterConfiguration   `queryParam:"inline,name=ComputeConfig"`
	GoogleGKEClusterConfiguration   *GoogleGKEClusterConfiguration   `queryParam:"inline,name=ComputeConfig"`
	UnivaGridEngineConfiguration    *UnivaGridEngineConfiguration    `queryParam:"inline,name=ComputeConfig"`
	AltairPBSConfiguration          *AltairPBSConfiguration          `queryParam:"inline,name=ComputeConfig"`
	MoabConfiguration               *MoabConfiguration               `queryParam:"inline,name=ComputeConfig"`

	Type ComputeConfigType
}

func CreateComputeConfigMoabPlatform(moabPlatform MoabConfiguration) ComputeConfig {
	typ := ComputeConfigTypeMoabPlatform

	typStr := string(typ)
	moabPlatform.Discriminator = &typStr

	return ComputeConfig{
		MoabConfiguration: &moabPlatform,
		Type:              typ,
	}
}

func CreateComputeConfigAwsBatch(awsBatch AWSBatchConfiguration) ComputeConfig {
	typ := ComputeConfigTypeAwsBatch

	typStr := string(typ)
	awsBatch.Discriminator = &typStr

	return ComputeConfig{
		AWSBatchConfiguration: &awsBatch,
		Type:                  typ,
	}
}

func CreateComputeConfigGkePlatform(gkePlatform GoogleGKEClusterConfiguration) ComputeConfig {
	typ := ComputeConfigTypeGkePlatform

	typStr := string(typ)
	gkePlatform.Discriminator = &typStr

	return ComputeConfig{
		GoogleGKEClusterConfiguration: &gkePlatform,
		Type:                          typ,
	}
}

func CreateComputeConfigGoogleBatch(googleBatch GoogleBatchServiceConfiguration) ComputeConfig {
	typ := ComputeConfigTypeGoogleBatch

	typStr := string(typ)
	googleBatch.Discriminator = &typStr

	return ComputeConfig{
		GoogleBatchServiceConfiguration: &googleBatch,
		Type:                            typ,
	}
}

func CreateComputeConfigAwsCloud(awsCloud AWSCloudConfiguration) ComputeConfig {
	typ := ComputeConfigTypeAwsCloud

	typStr := string(typ)
	awsCloud.Discriminator = &typStr

	return ComputeConfig{
		AWSCloudConfiguration: &awsCloud,
		Type:                  typ,
	}
}

func CreateComputeConfigSlurmPlatform(slurmPlatform SlurmConfiguration) ComputeConfig {
	typ := ComputeConfigTypeSlurmPlatform

	typStr := string(typ)
	slurmPlatform.Discriminator = &typStr

	return ComputeConfig{
		SlurmConfiguration: &slurmPlatform,
		Type:               typ,
	}
}

func CreateComputeConfigK8sPlatform(k8sPlatform KubernetesComputeConfiguration) ComputeConfig {
	typ := ComputeConfigTypeK8sPlatform

	typStr := string(typ)
	k8sPlatform.Discriminator = &typStr

	return ComputeConfig{
		KubernetesComputeConfiguration: &k8sPlatform,
		Type:                           typ,
	}
}

func CreateComputeConfigAltairPlatform(altairPlatform AltairPBSConfiguration) ComputeConfig {
	typ := ComputeConfigTypeAltairPlatform

	typStr := string(typ)
	altairPlatform.Discriminator = &typStr

	return ComputeConfig{
		AltairPBSConfiguration: &altairPlatform,
		Type:                   typ,
	}
}

func CreateComputeConfigLsfPlatform(lsfPlatform IBMLSFConfiguration) ComputeConfig {
	typ := ComputeConfigTypeLsfPlatform

	typStr := string(typ)
	lsfPlatform.Discriminator = &typStr

	return ComputeConfig{
		IBMLSFConfiguration: &lsfPlatform,
		Type:                typ,
	}
}

func CreateComputeConfigAzureBatch(azureBatch AzureBatchConfiguration) ComputeConfig {
	typ := ComputeConfigTypeAzureBatch

	typStr := string(typ)
	azureBatch.Discriminator = &typStr

	return ComputeConfig{
		AzureBatchConfiguration: &azureBatch,
		Type:                    typ,
	}
}

func CreateComputeConfigSeqeracomputePlatform(seqeracomputePlatform SeqeraComputeConfiguration) ComputeConfig {
	typ := ComputeConfigTypeSeqeracomputePlatform

	typStr := string(typ)
	seqeracomputePlatform.Discriminator = &typStr

	return ComputeConfig{
		SeqeraComputeConfiguration: &seqeracomputePlatform,
		Type:                       typ,
	}
}

func CreateComputeConfigEksPlatform(eksPlatform AmazonEKSClusterConfiguration) ComputeConfig {
	typ := ComputeConfigTypeEksPlatform

	typStr := string(typ)
	eksPlatform.Discriminator = &typStr

	return ComputeConfig{
		AmazonEKSClusterConfiguration: &eksPlatform,
		Type:                          typ,
	}
}

func CreateComputeConfigGoogleLifesciences(googleLifesciences GoogleLifeSciencesConfiguration) ComputeConfig {
	typ := ComputeConfigTypeGoogleLifesciences

	typStr := string(typ)
	googleLifesciences.Discriminator = &typStr

	return ComputeConfig{
		GoogleLifeSciencesConfiguration: &googleLifesciences,
		Type:                            typ,
	}
}

func CreateComputeConfigUgePlatform(ugePlatform UnivaGridEngineConfiguration) ComputeConfig {
	typ := ComputeConfigTypeUgePlatform

	typStr := string(typ)
	ugePlatform.Discriminator = &typStr

	return ComputeConfig{
		UnivaGridEngineConfiguration: &ugePlatform,
		Type:                         typ,
	}
}

func (u *ComputeConfig) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Discriminator string `json:"discriminator"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Discriminator {
	case "moab-platform":
		moabConfiguration := new(MoabConfiguration)
		if err := utils.UnmarshalJSON(data, &moabConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == moab-platform) type MoabConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.MoabConfiguration = moabConfiguration
		u.Type = ComputeConfigTypeMoabPlatform
		return nil
	case "aws-batch":
		awsBatchConfiguration := new(AWSBatchConfiguration)
		if err := utils.UnmarshalJSON(data, &awsBatchConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == aws-batch) type AWSBatchConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.AWSBatchConfiguration = awsBatchConfiguration
		u.Type = ComputeConfigTypeAwsBatch
		return nil
	case "gke-platform":
		googleGKEClusterConfiguration := new(GoogleGKEClusterConfiguration)
		if err := utils.UnmarshalJSON(data, &googleGKEClusterConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == gke-platform) type GoogleGKEClusterConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.GoogleGKEClusterConfiguration = googleGKEClusterConfiguration
		u.Type = ComputeConfigTypeGkePlatform
		return nil
	case "google-batch":
		googleBatchServiceConfiguration := new(GoogleBatchServiceConfiguration)
		if err := utils.UnmarshalJSON(data, &googleBatchServiceConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == google-batch) type GoogleBatchServiceConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.GoogleBatchServiceConfiguration = googleBatchServiceConfiguration
		u.Type = ComputeConfigTypeGoogleBatch
		return nil
	case "aws-cloud":
		awsCloudConfiguration := new(AWSCloudConfiguration)
		if err := utils.UnmarshalJSON(data, &awsCloudConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == aws-cloud) type AWSCloudConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.AWSCloudConfiguration = awsCloudConfiguration
		u.Type = ComputeConfigTypeAwsCloud
		return nil
	case "slurm-platform":
		slurmConfiguration := new(SlurmConfiguration)
		if err := utils.UnmarshalJSON(data, &slurmConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == slurm-platform) type SlurmConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.SlurmConfiguration = slurmConfiguration
		u.Type = ComputeConfigTypeSlurmPlatform
		return nil
	case "k8s-platform":
		kubernetesComputeConfiguration := new(KubernetesComputeConfiguration)
		if err := utils.UnmarshalJSON(data, &kubernetesComputeConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == k8s-platform) type KubernetesComputeConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.KubernetesComputeConfiguration = kubernetesComputeConfiguration
		u.Type = ComputeConfigTypeK8sPlatform
		return nil
	case "altair-platform":
		altairPBSConfiguration := new(AltairPBSConfiguration)
		if err := utils.UnmarshalJSON(data, &altairPBSConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == altair-platform) type AltairPBSConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.AltairPBSConfiguration = altairPBSConfiguration
		u.Type = ComputeConfigTypeAltairPlatform
		return nil
	case "lsf-platform":
		ibmLSFConfiguration := new(IBMLSFConfiguration)
		if err := utils.UnmarshalJSON(data, &ibmLSFConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == lsf-platform) type IBMLSFConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.IBMLSFConfiguration = ibmLSFConfiguration
		u.Type = ComputeConfigTypeLsfPlatform
		return nil
	case "azure-batch":
		azureBatchConfiguration := new(AzureBatchConfiguration)
		if err := utils.UnmarshalJSON(data, &azureBatchConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == azure-batch) type AzureBatchConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.AzureBatchConfiguration = azureBatchConfiguration
		u.Type = ComputeConfigTypeAzureBatch
		return nil
	case "seqeracompute-platform":
		seqeraComputeConfiguration := new(SeqeraComputeConfiguration)
		if err := utils.UnmarshalJSON(data, &seqeraComputeConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == seqeracompute-platform) type SeqeraComputeConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.SeqeraComputeConfiguration = seqeraComputeConfiguration
		u.Type = ComputeConfigTypeSeqeracomputePlatform
		return nil
	case "eks-platform":
		amazonEKSClusterConfiguration := new(AmazonEKSClusterConfiguration)
		if err := utils.UnmarshalJSON(data, &amazonEKSClusterConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == eks-platform) type AmazonEKSClusterConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.AmazonEKSClusterConfiguration = amazonEKSClusterConfiguration
		u.Type = ComputeConfigTypeEksPlatform
		return nil
	case "google-lifesciences":
		googleLifeSciencesConfiguration := new(GoogleLifeSciencesConfiguration)
		if err := utils.UnmarshalJSON(data, &googleLifeSciencesConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == google-lifesciences) type GoogleLifeSciencesConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.GoogleLifeSciencesConfiguration = googleLifeSciencesConfiguration
		u.Type = ComputeConfigTypeGoogleLifesciences
		return nil
	case "uge-platform":
		univaGridEngineConfiguration := new(UnivaGridEngineConfiguration)
		if err := utils.UnmarshalJSON(data, &univaGridEngineConfiguration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Discriminator == uge-platform) type UnivaGridEngineConfiguration within ComputeConfig: %w", string(data), err)
		}

		u.UnivaGridEngineConfiguration = univaGridEngineConfiguration
		u.Type = ComputeConfigTypeUgePlatform
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ComputeConfig", string(data))
}

func (u ComputeConfig) MarshalJSON() ([]byte, error) {
	if u.AWSBatchConfiguration != nil {
		return utils.MarshalJSON(u.AWSBatchConfiguration, "", true)
	}

	if u.AWSCloudConfiguration != nil {
		return utils.MarshalJSON(u.AWSCloudConfiguration, "", true)
	}

	if u.SeqeraComputeConfiguration != nil {
		return utils.MarshalJSON(u.SeqeraComputeConfiguration, "", true)
	}

	if u.GoogleLifeSciencesConfiguration != nil {
		return utils.MarshalJSON(u.GoogleLifeSciencesConfiguration, "", true)
	}

	if u.GoogleBatchServiceConfiguration != nil {
		return utils.MarshalJSON(u.GoogleBatchServiceConfiguration, "", true)
	}

	if u.AzureBatchConfiguration != nil {
		return utils.MarshalJSON(u.AzureBatchConfiguration, "", true)
	}

	if u.IBMLSFConfiguration != nil {
		return utils.MarshalJSON(u.IBMLSFConfiguration, "", true)
	}

	if u.SlurmConfiguration != nil {
		return utils.MarshalJSON(u.SlurmConfiguration, "", true)
	}

	if u.KubernetesComputeConfiguration != nil {
		return utils.MarshalJSON(u.KubernetesComputeConfiguration, "", true)
	}

	if u.AmazonEKSClusterConfiguration != nil {
		return utils.MarshalJSON(u.AmazonEKSClusterConfiguration, "", true)
	}

	if u.GoogleGKEClusterConfiguration != nil {
		return utils.MarshalJSON(u.GoogleGKEClusterConfiguration, "", true)
	}

	if u.UnivaGridEngineConfiguration != nil {
		return utils.MarshalJSON(u.UnivaGridEngineConfiguration, "", true)
	}

	if u.AltairPBSConfiguration != nil {
		return utils.MarshalJSON(u.AltairPBSConfiguration, "", true)
	}

	if u.MoabConfiguration != nil {
		return utils.MarshalJSON(u.MoabConfiguration, "", true)
	}

	return nil, errors.New("could not marshal union type ComputeConfig: all fields are null")
}
