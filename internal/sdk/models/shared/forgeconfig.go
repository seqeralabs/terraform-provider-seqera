// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/seqeralabs/terraform-provider-seqera/internal/sdk/internal/utils"
)

// ForgeConfigType - Type of compute instances to provision:
// - SPOT: Use EC2 Spot instances (cost-effective, can be interrupted)
// - EC2: Use On-Demand EC2 instances (reliable, higher cost)
// - FARGATE: Use AWS Fargate serverless compute
type ForgeConfigType string

const (
	ForgeConfigTypeSpot ForgeConfigType = "SPOT"
	ForgeConfigTypeEc2  ForgeConfigType = "EC2"
)

func (e ForgeConfigType) ToPointer() *ForgeConfigType {
	return &e
}
func (e *ForgeConfigType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SPOT":
		fallthrough
	case "EC2":
		*e = ForgeConfigType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ForgeConfigType: %v", v)
	}
}

// AllocStrategy - Strategy for allocating compute resources:
// - BEST_FIT: Selects instance type that best fits job requirements
// - BEST_FIT_PROGRESSIVE: Similar to BEST_FIT but widens search progressively
// - SPOT_CAPACITY_OPTIMIZED: For Spot instances, selects from pools with optimal capacity
// - SPOT_PRICE_CAPACITY_OPTIMIZED: Optimizes for both price and capacity
// Note: SPOT_CAPACITY_OPTIMIZED only valid when type is SPOT
type AllocStrategy string

const (
	AllocStrategyBestFit                    AllocStrategy = "BEST_FIT"
	AllocStrategyBestFitProgressive         AllocStrategy = "BEST_FIT_PROGRESSIVE"
	AllocStrategySpotCapacityOptimized      AllocStrategy = "SPOT_CAPACITY_OPTIMIZED"
	AllocStrategySpotPriceCapacityOptimized AllocStrategy = "SPOT_PRICE_CAPACITY_OPTIMIZED"
)

func (e AllocStrategy) ToPointer() *AllocStrategy {
	return &e
}
func (e *AllocStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BEST_FIT":
		fallthrough
	case "BEST_FIT_PROGRESSIVE":
		fallthrough
	case "SPOT_CAPACITY_OPTIMIZED":
		fallthrough
	case "SPOT_PRICE_CAPACITY_OPTIMIZED":
		*e = AllocStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllocStrategy: %v", v)
	}
}

type ForgeConfig struct {
	// Type of compute instances to provision:
	// - SPOT: Use EC2 Spot instances (cost-effective, can be interrupted)
	// - EC2: Use On-Demand EC2 instances (reliable, higher cost)
	// - FARGATE: Use AWS Fargate serverless compute
	//
	Type ForgeConfigType `json:"type"`
	// Minimum number of CPUs to maintain in the compute environment.
	// Setting to 0 allows environment to scale to zero when idle.
	//
	MinCpus int `json:"minCpus"`
	// Maximum number of CPUs available in the compute environment.
	// Subject to AWS service quotas.
	//
	MaxCpus int `json:"maxCpus"`
	// Enable GPU support for compute instances.
	// When enabled, GPU-capable instance types will be selected.
	//
	GpuEnabled *bool `json:"gpuEnabled,omitempty"`
	// Enable automatic EBS volume expansion.
	// When enabled, EBS volumes automatically expand as needed.
	//
	EbsAutoScale *bool `json:"ebsAutoScale,omitempty"`
	// List of EC2 instance types to use.
	// Examples: ["m5.xlarge", "m5.2xlarge"], ["c5.2xlarge"], ["p3.2xlarge"]
	// Default: ["optimal"] - AWS Batch selects appropriate instances
	//
	InstanceTypes []string `json:"instanceTypes,omitempty"`
	// Strategy for allocating compute resources:
	// - BEST_FIT: Selects instance type that best fits job requirements
	// - BEST_FIT_PROGRESSIVE: Similar to BEST_FIT but widens search progressively
	// - SPOT_CAPACITY_OPTIMIZED: For Spot instances, selects from pools with optimal capacity
	// - SPOT_PRICE_CAPACITY_OPTIMIZED: Optimizes for both price and capacity
	// Note: SPOT_CAPACITY_OPTIMIZED only valid when type is SPOT
	//
	AllocStrategy *AllocStrategy `json:"allocStrategy,omitempty"`
	ImageID       *string        `json:"imageId,omitempty"`
	// VPC ID where compute environment will be deployed.
	// Format: vpc- followed by hexadecimal characters
	//
	VpcID *string `json:"vpcId,omitempty"`
	// List of subnet IDs for compute instances.
	// Subnets must be in the specified VPC. Use multiple subnets for high availability.
	// Must have sufficient IP addresses.
	//
	Subnets []string `json:"subnets,omitempty"`
	// List of security group IDs to attach to compute instances.
	// Security groups must allow necessary network access.
	//
	SecurityGroups []string `json:"securityGroups,omitempty"`
	// Path where FSx will be mounted in the container.
	//
	FsxMount *string `json:"fsxMount,omitempty"`
	// FSx for Lustre file system name.
	//
	FsxName *string `json:"fsxName,omitempty"`
	// Size of FSx file system in GB.
	//
	FsxSize *int `json:"fsxSize,omitempty"`
	// Dispose of AWS Batch resources when compute environment is deleted.
	//
	DisposeOnDeletion *bool `json:"disposeOnDeletion,omitempty"`
	// EC2 key pair name for SSH access to compute instances.
	// Key pair must exist in the specified region.
	//
	Ec2KeyPair   *string  `json:"ec2KeyPair,omitempty"`
	AllowBuckets []string `json:"allowBuckets,omitempty"`
	// Size of EBS root volume in GB (minimum 8 GB, maximum 16 TB).
	//
	EbsBlockSize *int `json:"ebsBlockSize,omitempty"`
	// The maximum percentage that a Spot Instance price can be when compared with the On-Demand price
	// for that instance type before instances are launched. For example, if your maximum percentage is 20%,
	// then the Spot price must be less than 20% of the current On-Demand price for that Amazon EC2 instance.
	// You always pay the lowest (market) price and never more than your maximum percentage. If you leave this
	// field empty, the default value is 100% of the On-Demand price. For most use cases, we recommend leaving
	// this field empty.
	//
	// Must be a whole number between 0 and 100 (inclusive).
	//
	BidPercentage *int `json:"bidPercentage,omitempty"`
	// Automatically create an EFS file system
	EfsCreate *bool `json:"efsCreate,omitempty"`
	// EFS file system ID to mount.
	// Format: fs- followed by hexadecimal characters.
	// EFS must be in the same VPC and region.
	//
	EfsID *string `json:"efsId,omitempty"`
	// Path where EFS will be mounted in the container.
	//
	EfsMount      *string `json:"efsMount,omitempty"`
	DragenEnabled *bool   `json:"dragenEnabled,omitempty"`
	DragenAmiID   *string `json:"dragenAmiId,omitempty"`
	EbsBootSize   *int    `json:"ebsBootSize,omitempty"`
	EcsConfig     *string `json:"ecsConfig,omitempty"`
	// Use Fargate for head job instead of EC2.
	// Reduces costs by running head job on serverless compute.
	// Only applicable when using EC2 for worker jobs.
	//
	FargateHeadEnabled *bool   `json:"fargateHeadEnabled,omitempty"`
	Arm64Enabled       *bool   `json:"arm64Enabled,omitempty"`
	DragenInstanceType *string `json:"dragenInstanceType,omitempty"`
}

func (f ForgeConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *ForgeConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "minCpus", "maxCpus"}); err != nil {
		return err
	}
	return nil
}

func (f *ForgeConfig) GetType() ForgeConfigType {
	if f == nil {
		return ForgeConfigType("")
	}
	return f.Type
}

func (f *ForgeConfig) GetMinCpus() int {
	if f == nil {
		return 0
	}
	return f.MinCpus
}

func (f *ForgeConfig) GetMaxCpus() int {
	if f == nil {
		return 0
	}
	return f.MaxCpus
}

func (f *ForgeConfig) GetGpuEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.GpuEnabled
}

func (f *ForgeConfig) GetEbsAutoScale() *bool {
	if f == nil {
		return nil
	}
	return f.EbsAutoScale
}

func (f *ForgeConfig) GetInstanceTypes() []string {
	if f == nil {
		return nil
	}
	return f.InstanceTypes
}

func (f *ForgeConfig) GetAllocStrategy() *AllocStrategy {
	if f == nil {
		return nil
	}
	return f.AllocStrategy
}

func (f *ForgeConfig) GetImageID() *string {
	if f == nil {
		return nil
	}
	return f.ImageID
}

func (f *ForgeConfig) GetVpcID() *string {
	if f == nil {
		return nil
	}
	return f.VpcID
}

func (f *ForgeConfig) GetSubnets() []string {
	if f == nil {
		return nil
	}
	return f.Subnets
}

func (f *ForgeConfig) GetSecurityGroups() []string {
	if f == nil {
		return nil
	}
	return f.SecurityGroups
}

func (f *ForgeConfig) GetFsxMount() *string {
	if f == nil {
		return nil
	}
	return f.FsxMount
}

func (f *ForgeConfig) GetFsxName() *string {
	if f == nil {
		return nil
	}
	return f.FsxName
}

func (f *ForgeConfig) GetFsxSize() *int {
	if f == nil {
		return nil
	}
	return f.FsxSize
}

func (f *ForgeConfig) GetDisposeOnDeletion() *bool {
	if f == nil {
		return nil
	}
	return f.DisposeOnDeletion
}

func (f *ForgeConfig) GetEc2KeyPair() *string {
	if f == nil {
		return nil
	}
	return f.Ec2KeyPair
}

func (f *ForgeConfig) GetAllowBuckets() []string {
	if f == nil {
		return nil
	}
	return f.AllowBuckets
}

func (f *ForgeConfig) GetEbsBlockSize() *int {
	if f == nil {
		return nil
	}
	return f.EbsBlockSize
}

func (f *ForgeConfig) GetBidPercentage() *int {
	if f == nil {
		return nil
	}
	return f.BidPercentage
}

func (f *ForgeConfig) GetEfsCreate() *bool {
	if f == nil {
		return nil
	}
	return f.EfsCreate
}

func (f *ForgeConfig) GetEfsID() *string {
	if f == nil {
		return nil
	}
	return f.EfsID
}

func (f *ForgeConfig) GetEfsMount() *string {
	if f == nil {
		return nil
	}
	return f.EfsMount
}

func (f *ForgeConfig) GetDragenEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.DragenEnabled
}

func (f *ForgeConfig) GetDragenAmiID() *string {
	if f == nil {
		return nil
	}
	return f.DragenAmiID
}

func (f *ForgeConfig) GetEbsBootSize() *int {
	if f == nil {
		return nil
	}
	return f.EbsBootSize
}

func (f *ForgeConfig) GetEcsConfig() *string {
	if f == nil {
		return nil
	}
	return f.EcsConfig
}

func (f *ForgeConfig) GetFargateHeadEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.FargateHeadEnabled
}

func (f *ForgeConfig) GetArm64Enabled() *bool {
	if f == nil {
		return nil
	}
	return f.Arm64Enabled
}

func (f *ForgeConfig) GetDragenInstanceType() *string {
	if f == nil {
		return nil
	}
	return f.DragenInstanceType
}
